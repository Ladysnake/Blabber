{
	"title": "net.minecraft.world.ticks.LevelTicks",
	"items": [
		{
			"forge": "net.minecraft.world.ticks.LevelTicks",
			"fabric": "net.minecraft.world.tick.WorldTickScheduler"
		},
		{
			"forge": "CONTAINER_DRAIN_ORDER",
			"fabric": "COMPARATOR"
		},
		{
			"forge": "CONTAINER_DRAIN_ORDER",
			"fabric": "COMPARATOR"
		},
		{
			"forge": "tickCheck",
			"fabric": "tickingFutureReadyPredicate"
		},
		{
			"forge": "profiler",
			"fabric": "profilerGetter"
		},
		{
			"forge": "allContainers",
			"fabric": "chunkTickSchedulers"
		},
		{
			"forge": "nextTickForContainer",
			"fabric": "nextTriggerTickByChunkPos"
		},
		{
			"forge": "containersToTick",
			"fabric": "tickableChunkTickSchedulers"
		},
		{
			"forge": "toRunThisTick",
			"fabric": "tickableTicks"
		},
		{
			"forge": "alreadyRunThisTick",
			"fabric": "tickedTicks"
		},
		{
			"forge": "toRunThisTickSet",
			"fabric": "copiedTickableTicksList"
		},
		{
			"forge": "chunkScheduleUpdater",
			"fabric": "queuedTickConsumer"
		},
		{
			"forge": "addContainer(ChunkPos arg0, LevelChunkTicks<T> arg1)",
			"fabric": "addChunkTickScheduler(ChunkPos pos, ChunkTickScheduler<T> scheduler)"
		},
		{
			"forge": "addContainer(ChunkPos arg0, LevelChunkTicks<T> arg1)",
			"fabric": "addChunkTickScheduler(ChunkPos pos, ChunkTickScheduler<T> scheduler)"
		},
		{
			"forge": "removeContainer(ChunkPos arg0)",
			"fabric": "removeChunkTickScheduler(ChunkPos pos)"
		},
		{
			"forge": "schedule(ScheduledTick<T> arg0)",
			"fabric": "scheduleTick(OrderedTick<T> arg0)"
		},
		{
			"forge": "tick(long arg0, int arg1, BiConsumer<BlockPos, T> arg2)",
			"fabric": "tick(long time, int maxTicks, BiConsumer<BlockPos, T> ticker)"
		},
		{
			"forge": "collectTicks(long arg0, int arg1, ProfilerFiller arg2)",
			"fabric": "collectTickableTicks(long time, int maxTicks, Profiler profiler)"
		},
		{
			"forge": "sortContainersToTick(long arg0)",
			"fabric": "collectTickableChunkTickSchedulers(long time)"
		},
		{
			"forge": "drainContainers(long arg0, int arg1)",
			"fabric": "addTickableTicks(long time, int maxTicks)"
		},
		{
			"forge": "rescheduleLeftoverContainers()",
			"fabric": "delayAllTicks()"
		},
		{
			"forge": "updateContainerScheduling(ScheduledTick<T> arg0)",
			"fabric": "schedule(OrderedTick<T> tick)"
		},
		{
			"forge": "drainFromCurrentContainer(Queue<LevelChunkTicks<T>> arg0, LevelChunkTicks<T> arg1, long arg2, int arg3)",
			"fabric": "addTickableTicks(Queue<ChunkTickScheduler<T>> tickableChunkTickSchedulers, ChunkTickScheduler<T> chunkTickScheduler, long tick, int maxTicks)"
		},
		{
			"forge": "scheduleForThisTick(ScheduledTick<T> arg0)",
			"fabric": "addTickableTick(OrderedTick<T> tick)"
		},
		{
			"forge": "canScheduleMoreTicks(int arg0)",
			"fabric": "isTickableTicksCountUnder(int maxTicks)"
		},
		{
			"forge": "runCollectedTicks(BiConsumer<BlockPos, T> arg0)",
			"fabric": "tick(BiConsumer<BlockPos, T> ticker)"
		},
		{
			"forge": "cleanupAfterTick()",
			"fabric": "clear()"
		},
		{
			"forge": "hasScheduledTick(BlockPos arg0, T arg1)",
			"fabric": "isQueued(BlockPos arg0, T arg1)"
		},
		{
			"forge": "willTickThisTick(BlockPos arg0, T arg1)",
			"fabric": "isTicking(BlockPos arg0, T arg1)"
		},
		{
			"forge": "calculateTickSetIfNeeded()",
			"fabric": "copyTickableTicksList()"
		},
		{
			"forge": "forContainersInArea(BoundingBox arg0, LevelTicks$PosAndContainerConsumer<T> arg1)",
			"fabric": "visitChunks(BlockBox box, WorldTickScheduler$ChunkVisitor<T> visitor)"
		},
		{
			"forge": "clearArea(BoundingBox arg0)",
			"fabric": "clearNextTicks(BlockBox box)"
		},
		{
			"forge": "copyArea(BoundingBox arg0, Vec3i arg1)",
			"fabric": "scheduleTicks(BlockBox box, Vec3i offset)"
		},
		{
			"forge": "copyAreaFrom(LevelTicks<T> arg0, BoundingBox arg1, Vec3i arg2)",
			"fabric": "scheduleTicks(WorldTickScheduler<T> scheduler, BlockBox box, Vec3i offset)"
		},
		{
			"forge": "count()",
			"fabric": "getTickCount()"
		}
	]
}