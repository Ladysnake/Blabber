{
	"title": "net.minecraft.world.phys.shapes.Shapes",
	"items": [
		{
			"forge": "net.minecraft.world.phys.shapes.Shapes",
			"fabric": "net.minecraft.util.shape.VoxelShapes"
		},
		{
			"forge": "EPSILON",
			"fabric": "MIN_SIZE"
		},
		{
			"forge": "EPSILON",
			"fabric": "MIN_SIZE"
		},
		{
			"forge": "BIG_EPSILON",
			"fabric": "field_31881"
		},
		{
			"forge": "BLOCK",
			"fabric": "FULL_CUBE"
		},
		{
			"forge": "INFINITY",
			"fabric": "UNBOUNDED"
		},
		{
			"forge": "EMPTY",
			"fabric": "EMPTY"
		},
		{
			"forge": "empty()",
			"fabric": "empty()"
		},
		{
			"forge": "empty()",
			"fabric": "empty()"
		},
		{
			"forge": "block()",
			"fabric": "fullCube()"
		},
		{
			"forge": "box(double arg0, double arg1, double arg2, double arg3, double arg4, double arg5)",
			"fabric": "cuboid(double minX, double minY, double minZ, double maxX, double maxY, double maxZ)"
		},
		{
			"forge": "create(double arg0, double arg1, double arg2, double arg3, double arg4, double arg5)",
			"fabric": "cuboidUnchecked(double minX, double minY, double minZ, double maxX, double maxY, double maxZ)"
		},
		{
			"forge": "create(AABB arg0)",
			"fabric": "cuboid(Box box)"
		},
		{
			"forge": "findBits(double arg0, double arg1)",
			"fabric": "findRequiredBitResolution(double min, double max)"
		},
		{
			"forge": "lcm(int arg0, int arg1)",
			"fabric": "lcm(int a, int b)"
		},
		{
			"forge": "or(VoxelShape arg0, VoxelShape arg1)",
			"fabric": "union(VoxelShape first, VoxelShape second)"
		},
		{
			"forge": "or(VoxelShape arg0, VoxelShape... arg1)",
			"fabric": "union(VoxelShape first, VoxelShape... others)"
		},
		{
			"forge": "join(VoxelShape arg0, VoxelShape arg1, BooleanOp arg2)",
			"fabric": "combineAndSimplify(VoxelShape first, VoxelShape second, BooleanBiFunction function)"
		},
		{
			"forge": "joinUnoptimized(VoxelShape arg0, VoxelShape arg1, BooleanOp arg2)",
			"fabric": "combine(VoxelShape one, VoxelShape two, BooleanBiFunction function)"
		},
		{
			"forge": "joinIsNotEmpty(VoxelShape arg0, VoxelShape arg1, BooleanOp arg2)",
			"fabric": "matchesAnywhere(VoxelShape shape1, VoxelShape shape2, BooleanBiFunction predicate)"
		},
		{
			"forge": "joinIsNotEmpty(IndexMerger arg0, IndexMerger arg1, IndexMerger arg2, DiscreteVoxelShape arg3, DiscreteVoxelShape arg4, BooleanOp arg5)",
			"fabric": "matchesAnywhere(PairList mergedX, PairList mergedY, PairList mergedZ, VoxelSet shape1, VoxelSet shape2, BooleanBiFunction predicate)"
		},
		{
			"forge": "collide(Direction$Axis arg0, AABB arg1, Iterable<VoxelShape> arg2, double arg3)",
			"fabric": "calculateMaxOffset(Direction$Axis axis, Box box, Iterable<VoxelShape> shapes, double maxDist)"
		},
		{
			"forge": "blockOccudes(VoxelShape arg0, VoxelShape arg1, Direction arg2)",
			"fabric": "isSideCovered(VoxelShape shape, VoxelShape neighbor, Direction direction)"
		},
		{
			"forge": "getFaceShape(VoxelShape arg0, Direction arg1)",
			"fabric": "extrudeFace(VoxelShape shape, Direction direction)"
		},
		{
			"forge": "mergedFaceOccludes(VoxelShape arg0, VoxelShape arg1, Direction arg2)",
			"fabric": "adjacentSidesCoverSquare(VoxelShape one, VoxelShape two, Direction direction)"
		},
		{
			"forge": "faceShapeOccludes(VoxelShape arg0, VoxelShape arg1)",
			"fabric": "unionCoversFullCube(VoxelShape one, VoxelShape two)"
		},
		{
			"forge": "createIndexMerger(int arg0, it.unimi.dsi.fastutil.doubles.DoubleList arg1, it.unimi.dsi.fastutil.doubles.DoubleList arg2, boolean arg3, boolean arg4)",
			"fabric": "createListPair(int size, it.unimi.dsi.fastutil.doubles.DoubleList first, it.unimi.dsi.fastutil.doubles.DoubleList second, boolean includeFirst, boolean includeSecond)"
		}
	]
}