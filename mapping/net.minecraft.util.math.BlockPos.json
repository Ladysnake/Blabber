{
	"title": "net.minecraft.core.BlockPos",
	"items": [
		{
			"forge": "net.minecraft.core.BlockPos",
			"fabric": "net.minecraft.util.math.BlockPos"
		},
		{
			"forge": "CODEC",
			"fabric": "CODEC"
		},
		{
			"forge": "CODEC",
			"fabric": "CODEC"
		},
		{
			"forge": "LOGGER",
			"fabric": "LOGGER"
		},
		{
			"forge": "ZERO",
			"fabric": "ORIGIN"
		},
		{
			"forge": "PACKED_X_LENGTH",
			"fabric": "SIZE_BITS_X"
		},
		{
			"forge": "PACKED_Z_LENGTH",
			"fabric": "SIZE_BITS_Z"
		},
		{
			"forge": "PACKED_Y_LENGTH",
			"fabric": "SIZE_BITS_Y"
		},
		{
			"forge": "PACKED_X_MASK",
			"fabric": "BITS_X"
		},
		{
			"forge": "PACKED_Y_MASK",
			"fabric": "BITS_Y"
		},
		{
			"forge": "PACKED_Z_MASK",
			"fabric": "BITS_Z"
		},
		{
			"forge": "Y_OFFSET",
			"fabric": "field_33083"
		},
		{
			"forge": "Z_OFFSET",
			"fabric": "BIT_SHIFT_Z"
		},
		{
			"forge": "X_OFFSET",
			"fabric": "BIT_SHIFT_X"
		},
		{
			"forge": "offset(long arg0, Direction arg1)",
			"fabric": "offset(long value, Direction direction)"
		},
		{
			"forge": "offset(long arg0, Direction arg1)",
			"fabric": "offset(long value, Direction direction)"
		},
		{
			"forge": "offset(long arg0, int arg1, int arg2, int arg3)",
			"fabric": "add(long value, int x, int y, int z)"
		},
		{
			"forge": "getX(long arg0)",
			"fabric": "unpackLongX(long packedPos)"
		},
		{
			"forge": "getY(long arg0)",
			"fabric": "unpackLongY(long packedPos)"
		},
		{
			"forge": "getZ(long arg0)",
			"fabric": "unpackLongZ(long packedPos)"
		},
		{
			"forge": "of(long arg0)",
			"fabric": "fromLong(long packedPos)"
		},
		{
			"forge": "containing(double arg0, double arg1, double arg2)",
			"fabric": "ofFloored(double x, double y, double z)"
		},
		{
			"forge": "containing(Position arg0)",
			"fabric": "ofFloored(Position pos)"
		},
		{
			"forge": "asLong()",
			"fabric": "asLong()"
		},
		{
			"forge": "asLong(int arg0, int arg1, int arg2)",
			"fabric": "asLong(int x, int y, int z)"
		},
		{
			"forge": "getFlatIndex(long arg0)",
			"fabric": "removeChunkSectionLocalY(long y)"
		},
		{
			"forge": "offset(int arg0, int arg1, int arg2)",
			"fabric": "add(int arg0, int arg1, int arg2)"
		},
		{
			"forge": "getCenter()",
			"fabric": "toCenterPos()"
		},
		{
			"forge": "offset(Vec3i arg0)",
			"fabric": "add(Vec3i arg0)"
		},
		{
			"forge": "subtract(Vec3i arg0)",
			"fabric": "subtract(Vec3i arg0)"
		},
		{
			"forge": "multiply(int arg0)",
			"fabric": "multiply(int arg0)"
		},
		{
			"forge": "above()",
			"fabric": "up()"
		},
		{
			"forge": "above(int arg0)",
			"fabric": "up(int distance)"
		},
		{
			"forge": "below()",
			"fabric": "down()"
		},
		{
			"forge": "below(int arg0)",
			"fabric": "down(int arg0)"
		},
		{
			"forge": "north()",
			"fabric": "north()"
		},
		{
			"forge": "north(int arg0)",
			"fabric": "north(int distance)"
		},
		{
			"forge": "south()",
			"fabric": "south()"
		},
		{
			"forge": "south(int arg0)",
			"fabric": "south(int distance)"
		},
		{
			"forge": "west()",
			"fabric": "west()"
		},
		{
			"forge": "west(int arg0)",
			"fabric": "west(int distance)"
		},
		{
			"forge": "east()",
			"fabric": "east()"
		},
		{
			"forge": "east(int arg0)",
			"fabric": "east(int distance)"
		},
		{
			"forge": "relative(Direction arg0)",
			"fabric": "offset(Direction arg0)"
		},
		{
			"forge": "relative(Direction arg0, int arg1)",
			"fabric": "offset(Direction arg0, int arg1)"
		},
		{
			"forge": "relative(Direction$Axis arg0, int arg1)",
			"fabric": "offset(Direction$Axis arg0, int arg1)"
		},
		{
			"forge": "rotate(Rotation arg0)",
			"fabric": "rotate(BlockRotation rotation)"
		},
		{
			"forge": "cross(Vec3i arg0)",
			"fabric": "crossProduct(Vec3i pos)"
		},
		{
			"forge": "atY(int arg0)",
			"fabric": "withY(int y)"
		},
		{
			"forge": "immutable()",
			"fabric": "toImmutable()"
		},
		{
			"forge": "mutable()",
			"fabric": "mutableCopy()"
		},
		{
			"forge": "randomInCube(RandomSource arg0, int arg1, BlockPos arg2, int arg3)",
			"fabric": "iterateRandomly(Random random, int count, BlockPos around, int range)"
		},
		{
			"forge": "squareOutSouthEast(BlockPos arg0)",
			"fabric": "streamSouthEastSquare(BlockPos pos)"
		},
		{
			"forge": "randomBetweenClosed(RandomSource arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7)",
			"fabric": "iterateRandomly(Random random, int count, int minX, int minY, int minZ, int maxX, int maxY, int maxZ)"
		},
		{
			"forge": "withinManhattan(BlockPos arg0, int arg1, int arg2, int arg3)",
			"fabric": "iterateOutwards(BlockPos center, int rangeX, int rangeY, int rangeZ)"
		},
		{
			"forge": "findClosestMatch(BlockPos arg0, int arg1, int arg2, Predicate<BlockPos> arg3)",
			"fabric": "findClosest(BlockPos pos, int horizontalRange, int verticalRange, Predicate<BlockPos> condition)"
		},
		{
			"forge": "withinManhattanStream(BlockPos arg0, int arg1, int arg2, int arg3)",
			"fabric": "streamOutwards(BlockPos center, int maxX, int maxY, int maxZ)"
		},
		{
			"forge": "betweenClosed(BlockPos arg0, BlockPos arg1)",
			"fabric": "iterate(BlockPos start, BlockPos end)"
		},
		{
			"forge": "betweenClosedStream(BlockPos arg0, BlockPos arg1)",
			"fabric": "stream(BlockPos start, BlockPos end)"
		},
		{
			"forge": "betweenClosedStream(BoundingBox arg0)",
			"fabric": "stream(BlockBox box)"
		},
		{
			"forge": "betweenClosedStream(AABB arg0)",
			"fabric": "stream(Box box)"
		},
		{
			"forge": "betweenClosedStream(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)",
			"fabric": "stream(int startX, int startY, int startZ, int endX, int endY, int endZ)"
		},
		{
			"forge": "betweenClosed(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)",
			"fabric": "iterate(int startX, int startY, int startZ, int endX, int endY, int endZ)"
		},
		{
			"forge": "spiralAround(BlockPos arg0, int arg1, Direction arg2, Direction arg3)",
			"fabric": "iterateInSquare(BlockPos center, int radius, Direction firstDirection, Direction secondDirection)"
		},
		{
			"forge": "breadthFirstTraversal(BlockPos arg0, int arg1, int arg2, BiConsumer<BlockPos, Consumer<BlockPos>> arg3, Predicate<BlockPos> arg4)",
			"fabric": "iterateRecursively(BlockPos pos, int maxDepth, int maxIterations, BiConsumer<BlockPos, Consumer<BlockPos>> nextQueuer, Predicate<BlockPos> callback)"
		}
	]
}