{
	"title": "net.minecraft.world.level.block.state.BlockBehaviour",
	"items": [
		{
			"forge": "net.minecraft.world.level.block.state.BlockBehaviour",
			"fabric": "net.minecraft.block.AbstractBlock"
		},
		{
			"forge": "UPDATE_SHAPE_ORDER",
			"fabric": "DIRECTIONS"
		},
		{
			"forge": "UPDATE_SHAPE_ORDER",
			"fabric": "DIRECTIONS"
		},
		{
			"forge": "hasCollision",
			"fabric": "collidable"
		},
		{
			"forge": "explosionResistance",
			"fabric": "resistance"
		},
		{
			"forge": "isRandomlyTicking",
			"fabric": "randomTicks"
		},
		{
			"forge": "soundType",
			"fabric": "soundGroup"
		},
		{
			"forge": "friction",
			"fabric": "slipperiness"
		},
		{
			"forge": "speedFactor",
			"fabric": "velocityMultiplier"
		},
		{
			"forge": "jumpFactor",
			"fabric": "jumpVelocityMultiplier"
		},
		{
			"forge": "dynamicShape",
			"fabric": "dynamicBounds"
		},
		{
			"forge": "requiredFeatures",
			"fabric": "requiredFeatures"
		},
		{
			"forge": "properties",
			"fabric": "settings"
		},
		{
			"forge": "drops",
			"fabric": "lootTableId"
		},
		{
			"forge": "updateIndirectNeighbourShapes(BlockState arg0, LevelAccessor arg1, BlockPos arg2, int arg3, int arg4)",
			"fabric": "prepare(BlockState state, WorldAccess world, BlockPos pos, int flags, int maxUpdateDepth)"
		},
		{
			"forge": "updateIndirectNeighbourShapes(BlockState arg0, LevelAccessor arg1, BlockPos arg2, int arg3, int arg4)",
			"fabric": "prepare(BlockState state, WorldAccess world, BlockPos pos, int flags, int maxUpdateDepth)"
		},
		{
			"forge": "isPathfindable(BlockState arg0, BlockGetter arg1, BlockPos arg2, PathComputationType arg3)",
			"fabric": "canPathfindThrough(BlockState state, BlockView world, BlockPos pos, NavigationType type)"
		},
		{
			"forge": "updateShape(BlockState arg0, Direction arg1, BlockState arg2, LevelAccessor arg3, BlockPos arg4, BlockPos arg5)",
			"fabric": "getStateForNeighborUpdate(BlockState state, Direction direction, BlockState neighborState, WorldAccess world, BlockPos pos, BlockPos neighborPos)"
		},
		{
			"forge": "skipRendering(BlockState arg0, BlockState arg1, Direction arg2)",
			"fabric": "isSideInvisible(BlockState state, BlockState stateFrom, Direction direction)"
		},
		{
			"forge": "neighborChanged(BlockState arg0, Level arg1, BlockPos arg2, Block arg3, BlockPos arg4, boolean arg5)",
			"fabric": "neighborUpdate(BlockState state, World world, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify)"
		},
		{
			"forge": "onPlace(BlockState arg0, Level arg1, BlockPos arg2, BlockState arg3, boolean arg4)",
			"fabric": "onBlockAdded(BlockState state, World world, BlockPos pos, BlockState oldState, boolean notify)"
		},
		{
			"forge": "onRemove(BlockState arg0, Level arg1, BlockPos arg2, BlockState arg3, boolean arg4)",
			"fabric": "onStateReplaced(BlockState state, World world, BlockPos pos, BlockState newState, boolean moved)"
		},
		{
			"forge": "use(BlockState arg0, Level arg1, BlockPos arg2, Player arg3, InteractionHand arg4, BlockHitResult arg5)",
			"fabric": "onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit)"
		},
		{
			"forge": "triggerEvent(BlockState arg0, Level arg1, BlockPos arg2, int arg3, int arg4)",
			"fabric": "onSyncedBlockEvent(BlockState state, World world, BlockPos pos, int type, int data)"
		},
		{
			"forge": "getRenderShape(BlockState arg0)",
			"fabric": "getRenderType(BlockState state)"
		},
		{
			"forge": "useShapeForLightOcclusion(BlockState arg0)",
			"fabric": "hasSidedTransparency(BlockState state)"
		},
		{
			"forge": "isSignalSource(BlockState arg0)",
			"fabric": "emitsRedstonePower(BlockState state)"
		},
		{
			"forge": "getFluidState(BlockState arg0)",
			"fabric": "getFluidState(BlockState state)"
		},
		{
			"forge": "hasAnalogOutputSignal(BlockState arg0)",
			"fabric": "hasComparatorOutput(BlockState state)"
		},
		{
			"forge": "getMaxHorizontalOffset()",
			"fabric": "getMaxHorizontalModelOffset()"
		},
		{
			"forge": "getMaxVerticalOffset()",
			"fabric": "getVerticalModelOffsetMultiplier()"
		},
		{
			"forge": "requiredFeatures()",
			"fabric": "getRequiredFeatures()"
		},
		{
			"forge": "rotate(BlockState arg0, Rotation arg1)",
			"fabric": "rotate(BlockState state, BlockRotation rotation)"
		},
		{
			"forge": "mirror(BlockState arg0, Mirror arg1)",
			"fabric": "mirror(BlockState state, BlockMirror mirror)"
		},
		{
			"forge": "canBeReplaced(BlockState arg0, BlockPlaceContext arg1)",
			"fabric": "canReplace(BlockState state, ItemPlacementContext context)"
		},
		{
			"forge": "canBeReplaced(BlockState arg0, Fluid arg1)",
			"fabric": "canBucketPlace(BlockState state, Fluid fluid)"
		},
		{
			"forge": "getDrops(BlockState arg0, LootParams$Builder arg1)",
			"fabric": "getDroppedStacks(BlockState state, LootContextParameterSet$Builder builder)"
		},
		{
			"forge": "getSeed(BlockState arg0, BlockPos arg1)",
			"fabric": "getRenderingSeed(BlockState state, BlockPos pos)"
		},
		{
			"forge": "getOcclusionShape(BlockState arg0, BlockGetter arg1, BlockPos arg2)",
			"fabric": "getCullingShape(BlockState state, BlockView world, BlockPos pos)"
		},
		{
			"forge": "getBlockSupportShape(BlockState arg0, BlockGetter arg1, BlockPos arg2)",
			"fabric": "getSidesShape(BlockState state, BlockView world, BlockPos pos)"
		},
		{
			"forge": "getInteractionShape(BlockState arg0, BlockGetter arg1, BlockPos arg2)",
			"fabric": "getRaycastShape(BlockState state, BlockView world, BlockPos pos)"
		},
		{
			"forge": "getLightBlock(BlockState arg0, BlockGetter arg1, BlockPos arg2)",
			"fabric": "getOpacity(BlockState state, BlockView world, BlockPos pos)"
		},
		{
			"forge": "getMenuProvider(BlockState arg0, Level arg1, BlockPos arg2)",
			"fabric": "createScreenHandlerFactory(BlockState state, World world, BlockPos pos)"
		},
		{
			"forge": "canSurvive(BlockState arg0, LevelReader arg1, BlockPos arg2)",
			"fabric": "canPlaceAt(BlockState state, WorldView world, BlockPos pos)"
		},
		{
			"forge": "getShadeBrightness(BlockState arg0, BlockGetter arg1, BlockPos arg2)",
			"fabric": "getAmbientOcclusionLightLevel(BlockState state, BlockView world, BlockPos pos)"
		},
		{
			"forge": "getAnalogOutputSignal(BlockState arg0, Level arg1, BlockPos arg2)",
			"fabric": "getComparatorOutput(BlockState state, World world, BlockPos pos)"
		},
		{
			"forge": "getShape(BlockState arg0, BlockGetter arg1, BlockPos arg2, CollisionContext arg3)",
			"fabric": "getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context)"
		},
		{
			"forge": "getCollisionShape(BlockState arg0, BlockGetter arg1, BlockPos arg2, CollisionContext arg3)",
			"fabric": "getCollisionShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context)"
		},
		{
			"forge": "isCollisionShapeFullBlock(BlockState arg0, BlockGetter arg1, BlockPos arg2)",
			"fabric": "isShapeFullCube(BlockState state, BlockView world, BlockPos pos)"
		},
		{
			"forge": "isOcclusionShapeFullBlock(BlockState arg0, BlockGetter arg1, BlockPos arg2)",
			"fabric": "isCullingShapeFullCube(BlockState state, BlockView world, BlockPos pos)"
		},
		{
			"forge": "getVisualShape(BlockState arg0, BlockGetter arg1, BlockPos arg2, CollisionContext arg3)",
			"fabric": "getCameraCollisionShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context)"
		},
		{
			"forge": "randomTick(BlockState arg0, ServerLevel arg1, BlockPos arg2, RandomSource arg3)",
			"fabric": "randomTick(BlockState state, ServerWorld world, BlockPos pos, Random random)"
		},
		{
			"forge": "tick(BlockState arg0, ServerLevel arg1, BlockPos arg2, RandomSource arg3)",
			"fabric": "scheduledTick(BlockState state, ServerWorld world, BlockPos pos, Random random)"
		},
		{
			"forge": "getDestroyProgress(BlockState arg0, Player arg1, BlockGetter arg2, BlockPos arg3)",
			"fabric": "calcBlockBreakingDelta(BlockState state, PlayerEntity player, BlockView world, BlockPos pos)"
		},
		{
			"forge": "spawnAfterBreak(BlockState arg0, ServerLevel arg1, BlockPos arg2, ItemStack arg3, boolean arg4)",
			"fabric": "onStacksDropped(BlockState state, ServerWorld world, BlockPos pos, ItemStack tool, boolean dropExperience)"
		},
		{
			"forge": "attack(BlockState arg0, Level arg1, BlockPos arg2, Player arg3)",
			"fabric": "onBlockBreakStart(BlockState state, World world, BlockPos pos, PlayerEntity player)"
		},
		{
			"forge": "getSignal(BlockState arg0, BlockGetter arg1, BlockPos arg2, Direction arg3)",
			"fabric": "getWeakRedstonePower(BlockState state, BlockView world, BlockPos pos, Direction direction)"
		},
		{
			"forge": "entityInside(BlockState arg0, Level arg1, BlockPos arg2, Entity arg3)",
			"fabric": "onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity)"
		},
		{
			"forge": "getDirectSignal(BlockState arg0, BlockGetter arg1, BlockPos arg2, Direction arg3)",
			"fabric": "getStrongRedstonePower(BlockState state, BlockView world, BlockPos pos, Direction direction)"
		},
		{
			"forge": "getLootTable()",
			"fabric": "getLootTableId()"
		},
		{
			"forge": "onProjectileHit(Level arg0, BlockState arg1, BlockHitResult arg2, Projectile arg3)",
			"fabric": "onProjectileHit(World world, BlockState state, BlockHitResult hit, ProjectileEntity projectile)"
		},
		{
			"forge": "asItem()",
			"fabric": "asItem()"
		},
		{
			"forge": "asBlock()",
			"fabric": "asBlock()"
		},
		{
			"forge": "defaultMapColor()",
			"fabric": "getDefaultMapColor()"
		},
		{
			"forge": "defaultDestroyTime()",
			"fabric": "getHardness()"
		}
	]
}