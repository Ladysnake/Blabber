{
	"title": "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate",
	"items": [
		{
			"forge": "net.minecraft.world.level.levelgen.blockpredicates.BlockPredicate",
			"fabric": "net.minecraft.world.gen.blockpredicate.BlockPredicate"
		},
		{
			"forge": "CODEC",
			"fabric": "BASE_CODEC"
		},
		{
			"forge": "CODEC",
			"fabric": "BASE_CODEC"
		},
		{
			"forge": "ONLY_IN_AIR_PREDICATE",
			"fabric": "IS_AIR"
		},
		{
			"forge": "ONLY_IN_AIR_OR_WATER_PREDICATE",
			"fabric": "IS_AIR_OR_WATER"
		},
		{
			"forge": "type()",
			"fabric": "getType()"
		},
		{
			"forge": "type()",
			"fabric": "getType()"
		},
		{
			"forge": "allOf(List<BlockPredicate> arg0)",
			"fabric": "allOf(List<BlockPredicate> predicates)"
		},
		{
			"forge": "allOf(BlockPredicate... arg0)",
			"fabric": "allOf(BlockPredicate... predicates)"
		},
		{
			"forge": "allOf(BlockPredicate arg0, BlockPredicate arg1)",
			"fabric": "bothOf(BlockPredicate first, BlockPredicate second)"
		},
		{
			"forge": "anyOf(List<BlockPredicate> arg0)",
			"fabric": "anyOf(List<BlockPredicate> predicates)"
		},
		{
			"forge": "anyOf(BlockPredicate... arg0)",
			"fabric": "anyOf(BlockPredicate... predicates)"
		},
		{
			"forge": "anyOf(BlockPredicate arg0, BlockPredicate arg1)",
			"fabric": "eitherOf(BlockPredicate first, BlockPredicate second)"
		},
		{
			"forge": "matchesBlocks(Vec3i arg0, List<Block> arg1)",
			"fabric": "matchingBlocks(Vec3i offset, List<Block> blocks)"
		},
		{
			"forge": "matchesBlocks(List<Block> arg0)",
			"fabric": "matchingBlocks(List<Block> blocks)"
		},
		{
			"forge": "matchesBlocks(Vec3i arg0, Block... arg1)",
			"fabric": "matchingBlocks(Vec3i offset, Block... blocks)"
		},
		{
			"forge": "matchesBlocks(Block... arg0)",
			"fabric": "matchingBlocks(Block... blocks)"
		},
		{
			"forge": "matchesTag(Vec3i arg0, TagKey<Block> arg1)",
			"fabric": "matchingBlockTag(Vec3i offset, TagKey<Block> tag)"
		},
		{
			"forge": "matchesTag(TagKey<Block> arg0)",
			"fabric": "matchingBlockTag(TagKey<Block> offset)"
		},
		{
			"forge": "matchesFluids(Vec3i arg0, List<Fluid> arg1)",
			"fabric": "matchingFluids(Vec3i offset, List<Fluid> fluids)"
		},
		{
			"forge": "matchesFluids(Vec3i arg0, Fluid... arg1)",
			"fabric": "matchingFluids(Vec3i offset, Fluid... fluids)"
		},
		{
			"forge": "matchesFluids(Fluid... arg0)",
			"fabric": "matchingFluids(Fluid... fluids)"
		},
		{
			"forge": "not(BlockPredicate arg0)",
			"fabric": "not(BlockPredicate predicate)"
		},
		{
			"forge": "replaceable(Vec3i arg0)",
			"fabric": "replaceable(Vec3i offset)"
		},
		{
			"forge": "replaceable()",
			"fabric": "replaceable()"
		},
		{
			"forge": "wouldSurvive(BlockState arg0, Vec3i arg1)",
			"fabric": "wouldSurvive(BlockState state, Vec3i offset)"
		},
		{
			"forge": "hasSturdyFace(Vec3i arg0, Direction arg1)",
			"fabric": "hasSturdyFace(Vec3i offset, Direction face)"
		},
		{
			"forge": "hasSturdyFace(Direction arg0)",
			"fabric": "hasSturdyFace(Direction face)"
		},
		{
			"forge": "solid(Vec3i arg0)",
			"fabric": "solid(Vec3i offset)"
		},
		{
			"forge": "solid()",
			"fabric": "solid()"
		},
		{
			"forge": "noFluid()",
			"fabric": "noFluid()"
		},
		{
			"forge": "noFluid(Vec3i arg0)",
			"fabric": "noFluid(Vec3i offset)"
		},
		{
			"forge": "insideWorld(Vec3i arg0)",
			"fabric": "insideWorldBounds(Vec3i offset)"
		},
		{
			"forge": "alwaysTrue()",
			"fabric": "alwaysTrue()"
		}
	]
}