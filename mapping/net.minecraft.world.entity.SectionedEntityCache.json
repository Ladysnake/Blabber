{
	"title": "net.minecraft.world.level.entity.EntitySectionStorage",
	"items": [
		{
			"forge": "net.minecraft.world.level.entity.EntitySectionStorage",
			"fabric": "net.minecraft.world.entity.SectionedEntityCache"
		},
		{
			"forge": "entityClass",
			"fabric": "entityClass"
		},
		{
			"forge": "entityClass",
			"fabric": "entityClass"
		},
		{
			"forge": "intialSectionVisibility",
			"fabric": "posToStatus"
		},
		{
			"forge": "sections",
			"fabric": "trackingSections"
		},
		{
			"forge": "sectionIds",
			"fabric": "trackedPositions"
		},
		{
			"forge": "forEachAccessibleNonEmptySection(AABB arg0, AbortableIterationConsumer<EntitySection<T>> arg1)",
			"fabric": "forEachInBox(Box box, LazyIterationConsumer<EntityTrackingSection<T>> consumer)"
		},
		{
			"forge": "forEachAccessibleNonEmptySection(AABB arg0, AbortableIterationConsumer<EntitySection<T>> arg1)",
			"fabric": "forEachInBox(Box box, LazyIterationConsumer<EntityTrackingSection<T>> consumer)"
		},
		{
			"forge": "getExistingSectionPositionsInChunk(long arg0)",
			"fabric": "getSections(long chunkPos)"
		},
		{
			"forge": "getChunkSections(int arg0, int arg1)",
			"fabric": "getSections(int chunkX, int chunkZ)"
		},
		{
			"forge": "getExistingSectionsInChunk(long arg0)",
			"fabric": "getTrackingSections(long chunkPos)"
		},
		{
			"forge": "getChunkKeyFromSectionKey(long arg0)",
			"fabric": "chunkPosFromSectionPos(long sectionPos)"
		},
		{
			"forge": "getOrCreateSection(long arg0)",
			"fabric": "getTrackingSection(long sectionPos)"
		},
		{
			"forge": "getSection(long arg0)",
			"fabric": "findTrackingSection(long sectionPos)"
		},
		{
			"forge": "createSection(long arg0)",
			"fabric": "addSection(long sectionPos)"
		},
		{
			"forge": "getAllChunksWithExistingSections()",
			"fabric": "getChunkPositions()"
		},
		{
			"forge": "getEntities(AABB arg0, AbortableIterationConsumer<T> arg1)",
			"fabric": "forEachIntersects(Box box, LazyIterationConsumer<T> consumer)"
		},
		{
			"forge": "getEntities(EntityTypeTest<T, U> arg0, AABB arg1, AbortableIterationConsumer<U> arg2)",
			"fabric": "forEachIntersects(TypeFilter<T, U> filter, Box box, LazyIterationConsumer<U> consumer)"
		},
		{
			"forge": "remove(long arg0)",
			"fabric": "removeSection(long sectionPos)"
		},
		{
			"forge": "count()",
			"fabric": "sectionCount()"
		}
	]
}