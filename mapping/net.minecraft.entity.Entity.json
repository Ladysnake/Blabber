{
	"title": "net.minecraft.world.entity.Entity",
	"items": [
		{
			"forge": "net.minecraft.world.entity.Entity",
			"fabric": "net.minecraft.entity.Entity"
		},
		{
			"forge": "LOGGER",
			"fabric": "LOGGER"
		},
		{
			"forge": "LOGGER",
			"fabric": "LOGGER"
		},
		{
			"forge": "ID_TAG",
			"fabric": "ID_KEY"
		},
		{
			"forge": "PASSENGERS_TAG",
			"fabric": "PASSENGERS_KEY"
		},
		{
			"forge": "ENTITY_COUNTER",
			"fabric": "CURRENT_ID"
		},
		{
			"forge": "EMPTY_LIST",
			"fabric": "EMPTY_STACK_LIST"
		},
		{
			"forge": "BOARDING_COOLDOWN",
			"fabric": "MAX_RIDING_COOLDOWN"
		},
		{
			"forge": "TOTAL_AIR_SUPPLY",
			"fabric": "DEFAULT_PORTAL_COOLDOWN"
		},
		{
			"forge": "MAX_ENTITY_TAG_COUNT",
			"fabric": "MAX_COMMAND_TAGS"
		},
		{
			"forge": "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2",
			"fabric": "field_44870"
		},
		{
			"forge": "DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5",
			"fabric": "field_44871"
		},
		{
			"forge": "DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0",
			"fabric": "field_44872"
		},
		{
			"forge": "BREATHING_DISTANCE_BELOW_EYES",
			"fabric": "field_29991"
		},
		{
			"forge": "BASE_TICKS_REQUIRED_TO_FREEZE",
			"fabric": "DEFAULT_MIN_FREEZE_DAMAGE_TICKS"
		},
		{
			"forge": "FREEZE_HURT_FREQUENCY",
			"fabric": "FREEZING_DAMAGE_INTERVAL"
		},
		{
			"forge": "INITIAL_AABB",
			"fabric": "NULL_BOX"
		},
		{
			"forge": "WATER_FLOW_SCALE",
			"fabric": "SPEED_IN_WATER"
		},
		{
			"forge": "LAVA_FAST_FLOW_SCALE",
			"fabric": "SPEED_IN_LAVA_IN_NETHER"
		},
		{
			"forge": "LAVA_SLOW_FLOW_SCALE",
			"fabric": "SPEED_IN_LAVA"
		},
		{
			"forge": "UUID_TAG",
			"fabric": "UUID_KEY"
		},
		{
			"forge": "viewScale",
			"fabric": "renderDistanceMultiplier"
		},
		{
			"forge": "type",
			"fabric": "type"
		},
		{
			"forge": "id",
			"fabric": "id"
		},
		{
			"forge": "blocksBuilding",
			"fabric": "intersectionChecked"
		},
		{
			"forge": "passengers",
			"fabric": "passengerList"
		},
		{
			"forge": "boardingCooldown",
			"fabric": "ridingCooldown"
		},
		{
			"forge": "vehicle",
			"fabric": "vehicle"
		},
		{
			"forge": "level",
			"fabric": "world"
		},
		{
			"forge": "xo",
			"fabric": "prevX"
		},
		{
			"forge": "yo",
			"fabric": "prevY"
		},
		{
			"forge": "zo",
			"fabric": "prevZ"
		},
		{
			"forge": "position",
			"fabric": "pos"
		},
		{
			"forge": "blockPosition",
			"fabric": "blockPos"
		},
		{
			"forge": "chunkPosition",
			"fabric": "chunkPos"
		},
		{
			"forge": "deltaMovement",
			"fabric": "velocity"
		},
		{
			"forge": "yRot",
			"fabric": "yaw"
		},
		{
			"forge": "xRot",
			"fabric": "pitch"
		},
		{
			"forge": "yRotO",
			"fabric": "prevYaw"
		},
		{
			"forge": "xRotO",
			"fabric": "prevPitch"
		},
		{
			"forge": "bb",
			"fabric": "boundingBox"
		},
		{
			"forge": "onGround",
			"fabric": "onGround"
		},
		{
			"forge": "horizontalCollision",
			"fabric": "horizontalCollision"
		},
		{
			"forge": "verticalCollision",
			"fabric": "verticalCollision"
		},
		{
			"forge": "verticalCollisionBelow",
			"fabric": "groundCollision"
		},
		{
			"forge": "minorHorizontalCollision",
			"fabric": "collidedSoftly"
		},
		{
			"forge": "hurtMarked",
			"fabric": "velocityModified"
		},
		{
			"forge": "stuckSpeedMultiplier",
			"fabric": "movementMultiplier"
		},
		{
			"forge": "removalReason",
			"fabric": "removalReason"
		},
		{
			"forge": "DEFAULT_BB_WIDTH",
			"fabric": "DEFAULT_FRICTION"
		},
		{
			"forge": "DEFAULT_BB_HEIGHT",
			"fabric": "MIN_RISING_BUBBLE_COLUMN_SPEED"
		},
		{
			"forge": "walkDistO",
			"fabric": "prevHorizontalSpeed"
		},
		{
			"forge": "walkDist",
			"fabric": "horizontalSpeed"
		},
		{
			"forge": "moveDist",
			"fabric": "distanceTraveled"
		},
		{
			"forge": "flyDist",
			"fabric": "speed"
		},
		{
			"forge": "fallDistance",
			"fabric": "fallDistance"
		},
		{
			"forge": "nextStep",
			"fabric": "nextStepSoundDistance"
		},
		{
			"forge": "xOld",
			"fabric": "lastRenderX"
		},
		{
			"forge": "yOld",
			"fabric": "lastRenderY"
		},
		{
			"forge": "zOld",
			"fabric": "lastRenderZ"
		},
		{
			"forge": "maxUpStep",
			"fabric": "stepHeight"
		},
		{
			"forge": "noPhysics",
			"fabric": "noClip"
		},
		{
			"forge": "random",
			"fabric": "random"
		},
		{
			"forge": "tickCount",
			"fabric": "age"
		},
		{
			"forge": "remainingFireTicks",
			"fabric": "fireTicks"
		},
		{
			"forge": "wasTouchingWater",
			"fabric": "touchingWater"
		},
		{
			"forge": "fluidHeight",
			"fabric": "fluidHeight"
		},
		{
			"forge": "wasEyeInWater",
			"fabric": "submergedInWater"
		},
		{
			"forge": "fluidOnEyes",
			"fabric": "submergedFluidTag"
		},
		{
			"forge": "invulnerableTime",
			"fabric": "timeUntilRegen"
		},
		{
			"forge": "firstTick",
			"fabric": "firstUpdate"
		},
		{
			"forge": "entityData",
			"fabric": "dataTracker"
		},
		{
			"forge": "DATA_SHARED_FLAGS_ID",
			"fabric": "FLAGS"
		},
		{
			"forge": "FLAG_ONFIRE",
			"fabric": "ON_FIRE_FLAG_INDEX"
		},
		{
			"forge": "FLAG_SHIFT_KEY_DOWN",
			"fabric": "SNEAKING_FLAG_INDEX"
		},
		{
			"forge": "FLAG_SPRINTING",
			"fabric": "SPRINTING_FLAG_INDEX"
		},
		{
			"forge": "FLAG_SWIMMING",
			"fabric": "SWIMMING_FLAG_INDEX"
		},
		{
			"forge": "FLAG_INVISIBLE",
			"fabric": "INVISIBLE_FLAG_INDEX"
		},
		{
			"forge": "FLAG_GLOWING",
			"fabric": "GLOWING_FLAG_INDEX"
		},
		{
			"forge": "FLAG_FALL_FLYING",
			"fabric": "FALL_FLYING_FLAG_INDEX"
		},
		{
			"forge": "DATA_AIR_SUPPLY_ID",
			"fabric": "AIR"
		},
		{
			"forge": "DATA_CUSTOM_NAME",
			"fabric": "CUSTOM_NAME"
		},
		{
			"forge": "DATA_CUSTOM_NAME_VISIBLE",
			"fabric": "NAME_VISIBLE"
		},
		{
			"forge": "DATA_SILENT",
			"fabric": "SILENT"
		},
		{
			"forge": "DATA_NO_GRAVITY",
			"fabric": "NO_GRAVITY"
		},
		{
			"forge": "DATA_POSE",
			"fabric": "POSE"
		},
		{
			"forge": "DATA_TICKS_FROZEN",
			"fabric": "FROZEN_TICKS"
		},
		{
			"forge": "levelCallback",
			"fabric": "changeListener"
		},
		{
			"forge": "packetPositionCodec",
			"fabric": "trackedPosition"
		},
		{
			"forge": "noCulling",
			"fabric": "ignoreCameraFrustum"
		},
		{
			"forge": "hasImpulse",
			"fabric": "velocityDirty"
		},
		{
			"forge": "portalCooldown",
			"fabric": "portalCooldown"
		},
		{
			"forge": "isInsidePortal",
			"fabric": "inNetherPortal"
		},
		{
			"forge": "portalTime",
			"fabric": "netherPortalTime"
		},
		{
			"forge": "portalEntrancePos",
			"fabric": "lastNetherPortalPosition"
		},
		{
			"forge": "invulnerable",
			"fabric": "invulnerable"
		},
		{
			"forge": "uuid",
			"fabric": "uuid"
		},
		{
			"forge": "stringUUID",
			"fabric": "uuidString"
		},
		{
			"forge": "hasGlowingTag",
			"fabric": "glowing"
		},
		{
			"forge": "tags",
			"fabric": "commandTags"
		},
		{
			"forge": "pistonDeltas",
			"fabric": "pistonMovementDelta"
		},
		{
			"forge": "pistonDeltasGameTime",
			"fabric": "pistonMovementTick"
		},
		{
			"forge": "dimensions",
			"fabric": "dimensions"
		},
		{
			"forge": "eyeHeight",
			"fabric": "standingEyeHeight"
		},
		{
			"forge": "isInPowderSnow",
			"fabric": "inPowderSnow"
		},
		{
			"forge": "wasInPowderSnow",
			"fabric": "wasInPowderSnow"
		},
		{
			"forge": "wasOnFire",
			"fabric": "wasOnFire"
		},
		{
			"forge": "mainSupportingBlockPos",
			"fabric": "supportingBlockPos"
		},
		{
			"forge": "onGroundNoBlocks",
			"fabric": "forceUpdateSupportingBlockPos"
		},
		{
			"forge": "crystalSoundIntensity",
			"fabric": "lastChimeIntensity"
		},
		{
			"forge": "lastCrystalSoundPlayTick",
			"fabric": "lastChimeAge"
		},
		{
			"forge": "hasVisualFire",
			"fabric": "hasVisualFire"
		},
		{
			"forge": "feetBlockState",
			"fabric": "blockStateAtPos"
		},
		{
			"forge": "isColliding(BlockPos arg0, BlockState arg1)",
			"fabric": "collidesWithStateAtPos(BlockPos pos, BlockState state)"
		},
		{
			"forge": "isColliding(BlockPos arg0, BlockState arg1)",
			"fabric": "collidesWithStateAtPos(BlockPos pos, BlockState state)"
		},
		{
			"forge": "getTeamColor()",
			"fabric": "getTeamColorValue()"
		},
		{
			"forge": "isSpectator()",
			"fabric": "isSpectator()"
		},
		{
			"forge": "unRide()",
			"fabric": "detach()"
		},
		{
			"forge": "syncPacketPositionCodec(double arg0, double arg1, double arg2)",
			"fabric": "updateTrackedPosition(double x, double y, double z)"
		},
		{
			"forge": "getPositionCodec()",
			"fabric": "getTrackedPosition()"
		},
		{
			"forge": "getType()",
			"fabric": "getType()"
		},
		{
			"forge": "getId()",
			"fabric": "getId()"
		},
		{
			"forge": "setId(int arg0)",
			"fabric": "setId(int id)"
		},
		{
			"forge": "getTags()",
			"fabric": "getCommandTags()"
		},
		{
			"forge": "addTag(String arg0)",
			"fabric": "addCommandTag(String tag)"
		},
		{
			"forge": "removeTag(String arg0)",
			"fabric": "removeScoreboardTag(String tag)"
		},
		{
			"forge": "kill()",
			"fabric": "kill()"
		},
		{
			"forge": "discard()",
			"fabric": "discard()"
		},
		{
			"forge": "defineSynchedData()",
			"fabric": "initDataTracker()"
		},
		{
			"forge": "getEntityData()",
			"fabric": "getDataTracker()"
		},
		{
			"forge": "remove(Entity$RemovalReason arg0)",
			"fabric": "remove(Entity$RemovalReason reason)"
		},
		{
			"forge": "onClientRemoval()",
			"fabric": "onRemoved()"
		},
		{
			"forge": "setPose(Pose arg0)",
			"fabric": "setPose(EntityPose pose)"
		},
		{
			"forge": "getPose()",
			"fabric": "getPose()"
		},
		{
			"forge": "hasPose(Pose arg0)",
			"fabric": "isInPose(EntityPose pose)"
		},
		{
			"forge": "closerThan(Entity arg0, double arg1)",
			"fabric": "isInRange(Entity entity, double radius)"
		},
		{
			"forge": "closerThan(Entity arg0, double arg1, double arg2)",
			"fabric": "isInRange(Entity entity, double horizontalRadius, double verticalRadius)"
		},
		{
			"forge": "setRot(float arg0, float arg1)",
			"fabric": "setRotation(float yaw, float pitch)"
		},
		{
			"forge": "setPos(Vec3 arg0)",
			"fabric": "setPosition(Vec3d pos)"
		},
		{
			"forge": "setPos(double arg0, double arg1, double arg2)",
			"fabric": "setPosition(double x, double y, double z)"
		},
		{
			"forge": "makeBoundingBox()",
			"fabric": "calculateBoundingBox()"
		},
		{
			"forge": "reapplyPosition()",
			"fabric": "refreshPosition()"
		},
		{
			"forge": "turn(double arg0, double arg1)",
			"fabric": "changeLookDirection(double cursorDeltaX, double cursorDeltaY)"
		},
		{
			"forge": "tick()",
			"fabric": "tick()"
		},
		{
			"forge": "baseTick()",
			"fabric": "baseTick()"
		},
		{
			"forge": "setSharedFlagOnFire(boolean arg0)",
			"fabric": "setOnFire(boolean onFire)"
		},
		{
			"forge": "checkBelowWorld()",
			"fabric": "attemptTickInVoid()"
		},
		{
			"forge": "setPortalCooldown()",
			"fabric": "resetPortalCooldown()"
		},
		{
			"forge": "setPortalCooldown(int arg0)",
			"fabric": "setPortalCooldown(int portalCooldown)"
		},
		{
			"forge": "getPortalCooldown()",
			"fabric": "getPortalCooldown()"
		},
		{
			"forge": "isOnPortalCooldown()",
			"fabric": "hasPortalCooldown()"
		},
		{
			"forge": "processPortalCooldown()",
			"fabric": "tickPortalCooldown()"
		},
		{
			"forge": "getPortalWaitTime()",
			"fabric": "getMaxNetherPortalTime()"
		},
		{
			"forge": "lavaHurt()",
			"fabric": "setOnFireFromLava()"
		},
		{
			"forge": "setSecondsOnFire(int arg0)",
			"fabric": "setOnFireFor(int seconds)"
		},
		{
			"forge": "setRemainingFireTicks(int arg0)",
			"fabric": "setFireTicks(int fireTicks)"
		},
		{
			"forge": "getRemainingFireTicks()",
			"fabric": "getFireTicks()"
		},
		{
			"forge": "clearFire()",
			"fabric": "extinguish()"
		},
		{
			"forge": "onBelowWorld()",
			"fabric": "tickInVoid()"
		},
		{
			"forge": "isFree(double arg0, double arg1, double arg2)",
			"fabric": "doesNotCollide(double offsetX, double offsetY, double offsetZ)"
		},
		{
			"forge": "isFree(AABB arg0)",
			"fabric": "doesNotCollide(Box box)"
		},
		{
			"forge": "setOnGround(boolean arg0)",
			"fabric": "setOnGround(boolean onGround)"
		},
		{
			"forge": "setOnGroundWithKnownMovement(boolean arg0, Vec3 arg1)",
			"fabric": "setOnGround(boolean onGround, Vec3d movement)"
		},
		{
			"forge": "isSupportedBy(BlockPos arg0)",
			"fabric": "isSupportedBy(BlockPos pos)"
		},
		{
			"forge": "checkSupportingBlock(boolean arg0, Vec3 arg1)",
			"fabric": "updateSupportingBlockPos(boolean onGround, Vec3d movement)"
		},
		{
			"forge": "onGround()",
			"fabric": "isOnGround()"
		},
		{
			"forge": "move(MoverType arg0, Vec3 arg1)",
			"fabric": "move(MovementType movementType, Vec3d movement)"
		},
		{
			"forge": "isStateClimbable(BlockState arg0)",
			"fabric": "canClimb(BlockState state)"
		},
		{
			"forge": "vibrationAndSoundEffectsFromBlock(BlockPos arg0, BlockState arg1, boolean arg2, boolean arg3, Vec3 arg4)",
			"fabric": "stepOnBlock(BlockPos pos, BlockState state, boolean playSound, boolean emitEvent, Vec3d movement)"
		},
		{
			"forge": "isHorizontalCollisionMinor(Vec3 arg0)",
			"fabric": "hasCollidedSoftly(Vec3d adjustedMovement)"
		},
		{
			"forge": "tryCheckInsideBlocks()",
			"fabric": "tryCheckBlockCollision()"
		},
		{
			"forge": "playEntityOnFireExtinguishedSound()",
			"fabric": "playExtinguishSound()"
		},
		{
			"forge": "extinguishFire()",
			"fabric": "extinguishWithSound()"
		},
		{
			"forge": "processFlappingMovement()",
			"fabric": "addAirTravelEffects()"
		},
		{
			"forge": "getOnPosLegacy()",
			"fabric": "getLandingPos()"
		},
		{
			"forge": "getBlockPosBelowThatAffectsMyMovement()",
			"fabric": "getVelocityAffectingPos()"
		},
		{
			"forge": "getOnPos()",
			"fabric": "getSteppingPos()"
		},
		{
			"forge": "getOnPos(float arg0)",
			"fabric": "getPosWithYOffset(float offset)"
		},
		{
			"forge": "getBlockJumpFactor()",
			"fabric": "getJumpVelocityMultiplier()"
		},
		{
			"forge": "getBlockSpeedFactor()",
			"fabric": "getVelocityMultiplier()"
		},
		{
			"forge": "maybeBackOffFromEdge(Vec3 arg0, MoverType arg1)",
			"fabric": "adjustMovementForSneaking(Vec3d movement, MovementType type)"
		},
		{
			"forge": "limitPistonMovement(Vec3 arg0)",
			"fabric": "adjustMovementForPiston(Vec3d movement)"
		},
		{
			"forge": "applyPistonMovementRestriction(Direction$Axis arg0, double arg1)",
			"fabric": "calculatePistonMovementFactor(Direction$Axis axis, double offsetFactor)"
		},
		{
			"forge": "collide(Vec3 arg0)",
			"fabric": "adjustMovementForCollisions(Vec3d movement)"
		},
		{
			"forge": "collideBoundingBox(Entity arg0, Vec3 arg1, AABB arg2, Level arg3, List<VoxelShape> arg4)",
			"fabric": "adjustMovementForCollisions(Entity entity, Vec3d movement, Box entityBoundingBox, World world, List<VoxelShape> collisions)"
		},
		{
			"forge": "collideWithShapes(Vec3 arg0, AABB arg1, List<VoxelShape> arg2)",
			"fabric": "adjustMovementForCollisions(Vec3d movement, Box entityBoundingBox, List<VoxelShape> collisions)"
		},
		{
			"forge": "nextStep()",
			"fabric": "calculateNextStepSoundDistance()"
		},
		{
			"forge": "getSwimSound()",
			"fabric": "getSwimSound()"
		},
		{
			"forge": "getSwimSplashSound()",
			"fabric": "getSplashSound()"
		},
		{
			"forge": "getSwimHighSpeedSplashSound()",
			"fabric": "getHighSpeedSplashSound()"
		},
		{
			"forge": "checkInsideBlocks()",
			"fabric": "checkBlockCollision()"
		},
		{
			"forge": "onInsideBlock(BlockState arg0)",
			"fabric": "onBlockCollision(BlockState state)"
		},
		{
			"forge": "gameEvent(GameEvent arg0, Entity arg1)",
			"fabric": "emitGameEvent(GameEvent event, Entity entity)"
		},
		{
			"forge": "gameEvent(GameEvent arg0)",
			"fabric": "emitGameEvent(GameEvent event)"
		},
		{
			"forge": "walkingStepSound(BlockPos arg0, BlockState arg1)",
			"fabric": "playStepSounds(BlockPos pos, BlockState state)"
		},
		{
			"forge": "waterSwimSound()",
			"fabric": "playSwimSound()"
		},
		{
			"forge": "getPrimaryStepSoundBlockPos(BlockPos arg0)",
			"fabric": "getStepSoundPos(BlockPos pos)"
		},
		{
			"forge": "playCombinationStepSounds(BlockState arg0, BlockState arg1)",
			"fabric": "playCombinationStepSounds(BlockState primaryState, BlockState secondaryState)"
		},
		{
			"forge": "playMuffledStepSound(BlockState arg0)",
			"fabric": "playSecondaryStepSound(BlockState state)"
		},
		{
			"forge": "playStepSound(BlockPos arg0, BlockState arg1)",
			"fabric": "playStepSound(BlockPos pos, BlockState state)"
		},
		{
			"forge": "shouldPlayAmethystStepSound(BlockState arg0)",
			"fabric": "shouldPlayAmethystChimeSound(BlockState state)"
		},
		{
			"forge": "playAmethystStepSound()",
			"fabric": "playAmethystChimeSound()"
		},
		{
			"forge": "playSwimSound(float arg0)",
			"fabric": "playSwimSound(float volume)"
		},
		{
			"forge": "onFlap()",
			"fabric": "addFlapEffects()"
		},
		{
			"forge": "isFlapping()",
			"fabric": "isFlappingWings()"
		},
		{
			"forge": "playSound(SoundEvent arg0, float arg1, float arg2)",
			"fabric": "playSound(SoundEvent sound, float volume, float pitch)"
		},
		{
			"forge": "playSound(SoundEvent arg0)",
			"fabric": "playSoundIfNotSilent(SoundEvent event)"
		},
		{
			"forge": "isSilent()",
			"fabric": "isSilent()"
		},
		{
			"forge": "setSilent(boolean arg0)",
			"fabric": "setSilent(boolean silent)"
		},
		{
			"forge": "isNoGravity()",
			"fabric": "hasNoGravity()"
		},
		{
			"forge": "setNoGravity(boolean arg0)",
			"fabric": "setNoGravity(boolean noGravity)"
		},
		{
			"forge": "getMovementEmission()",
			"fabric": "getMoveEffect()"
		},
		{
			"forge": "dampensVibrations()",
			"fabric": "occludeVibrationSignals()"
		},
		{
			"forge": "checkFallDamage(double arg0, boolean arg1, BlockState arg2, BlockPos arg3)",
			"fabric": "fall(double heightDifference, boolean onGround, BlockState state, BlockPos landedPosition)"
		},
		{
			"forge": "fireImmune()",
			"fabric": "isFireImmune()"
		},
		{
			"forge": "causeFallDamage(float arg0, float arg1, DamageSource arg2)",
			"fabric": "handleFallDamage(float fallDistance, float damageMultiplier, DamageSource damageSource)"
		},
		{
			"forge": "isInWater()",
			"fabric": "isTouchingWater()"
		},
		{
			"forge": "isInRain()",
			"fabric": "isBeingRainedOn()"
		},
		{
			"forge": "isInBubbleColumn()",
			"fabric": "isInsideBubbleColumn()"
		},
		{
			"forge": "isInWaterOrRain()",
			"fabric": "isTouchingWaterOrRain()"
		},
		{
			"forge": "isInWaterRainOrBubble()",
			"fabric": "isWet()"
		},
		{
			"forge": "isInWaterOrBubble()",
			"fabric": "isInsideWaterOrBubbleColumn()"
		},
		{
			"forge": "isUnderWater()",
			"fabric": "isSubmergedInWater()"
		},
		{
			"forge": "updateSwimming()",
			"fabric": "updateSwimming()"
		},
		{
			"forge": "updateInWaterStateAndDoFluidPushing()",
			"fabric": "updateWaterState()"
		},
		{
			"forge": "updateInWaterStateAndDoWaterCurrentPushing()",
			"fabric": "checkWaterState()"
		},
		{
			"forge": "updateFluidOnEyes()",
			"fabric": "updateSubmergedInWaterState()"
		},
		{
			"forge": "doWaterSplashEffect()",
			"fabric": "onSwimmingStart()"
		},
		{
			"forge": "getBlockStateOnLegacy()",
			"fabric": "getLandingBlockState()"
		},
		{
			"forge": "getBlockStateOn()",
			"fabric": "getSteppingBlockState()"
		},
		{
			"forge": "canSpawnSprintParticle()",
			"fabric": "shouldSpawnSprintingParticles()"
		},
		{
			"forge": "spawnSprintParticle()",
			"fabric": "spawnSprintingParticles()"
		},
		{
			"forge": "isEyeInFluid(TagKey<Fluid> arg0)",
			"fabric": "isSubmergedIn(TagKey<Fluid> fluidTag)"
		},
		{
			"forge": "isInLava()",
			"fabric": "isInLava()"
		},
		{
			"forge": "moveRelative(float arg0, Vec3 arg1)",
			"fabric": "updateVelocity(float speed, Vec3d movementInput)"
		},
		{
			"forge": "getInputVector(Vec3 arg0, float arg1, float arg2)",
			"fabric": "movementInputToVelocity(Vec3d movementInput, float speed, float yaw)"
		},
		{
			"forge": "getLightLevelDependentMagicValue()",
			"fabric": "getBrightnessAtEyes()"
		},
		{
			"forge": "absMoveTo(double arg0, double arg1, double arg2, float arg3, float arg4)",
			"fabric": "updatePositionAndAngles(double x, double y, double z, float yaw, float pitch)"
		},
		{
			"forge": "absMoveTo(double arg0, double arg1, double arg2)",
			"fabric": "updatePosition(double x, double y, double z)"
		},
		{
			"forge": "moveTo(Vec3 arg0)",
			"fabric": "refreshPositionAfterTeleport(Vec3d pos)"
		},
		{
			"forge": "moveTo(double arg0, double arg1, double arg2)",
			"fabric": "refreshPositionAfterTeleport(double x, double y, double z)"
		},
		{
			"forge": "moveTo(BlockPos arg0, float arg1, float arg2)",
			"fabric": "refreshPositionAndAngles(BlockPos pos, float yaw, float pitch)"
		},
		{
			"forge": "moveTo(double arg0, double arg1, double arg2, float arg3, float arg4)",
			"fabric": "refreshPositionAndAngles(double x, double y, double z, float yaw, float pitch)"
		},
		{
			"forge": "setOldPosAndRot()",
			"fabric": "resetPosition()"
		},
		{
			"forge": "distanceTo(Entity arg0)",
			"fabric": "distanceTo(Entity entity)"
		},
		{
			"forge": "distanceToSqr(double arg0, double arg1, double arg2)",
			"fabric": "squaredDistanceTo(double x, double y, double z)"
		},
		{
			"forge": "distanceToSqr(Entity arg0)",
			"fabric": "squaredDistanceTo(Entity entity)"
		},
		{
			"forge": "distanceToSqr(Vec3 arg0)",
			"fabric": "squaredDistanceTo(Vec3d vector)"
		},
		{
			"forge": "playerTouch(Player arg0)",
			"fabric": "onPlayerCollision(PlayerEntity player)"
		},
		{
			"forge": "push(Entity arg0)",
			"fabric": "pushAwayFrom(Entity entity)"
		},
		{
			"forge": "push(double arg0, double arg1, double arg2)",
			"fabric": "addVelocity(double deltaX, double deltaY, double deltaZ)"
		},
		{
			"forge": "markHurt()",
			"fabric": "scheduleVelocityUpdate()"
		},
		{
			"forge": "hurt(DamageSource arg0, float arg1)",
			"fabric": "damage(DamageSource source, float amount)"
		},
		{
			"forge": "getViewVector(float arg0)",
			"fabric": "getRotationVec(float tickDelta)"
		},
		{
			"forge": "getViewXRot(float arg0)",
			"fabric": "getPitch(float tickDelta)"
		},
		{
			"forge": "getViewYRot(float arg0)",
			"fabric": "getYaw(float tickDelta)"
		},
		{
			"forge": "calculateViewVector(float arg0, float arg1)",
			"fabric": "getRotationVector(float pitch, float yaw)"
		},
		{
			"forge": "getUpVector(float arg0)",
			"fabric": "getOppositeRotationVector(float tickDelta)"
		},
		{
			"forge": "calculateUpVector(float arg0, float arg1)",
			"fabric": "getOppositeRotationVector(float pitch, float yaw)"
		},
		{
			"forge": "getEyePosition()",
			"fabric": "getEyePos()"
		},
		{
			"forge": "getEyePosition(float arg0)",
			"fabric": "getCameraPosVec(float tickDelta)"
		},
		{
			"forge": "getLightProbePosition(float arg0)",
			"fabric": "getClientCameraPosVec(float tickDelta)"
		},
		{
			"forge": "getPosition(float arg0)",
			"fabric": "getLerpedPos(float delta)"
		},
		{
			"forge": "pick(double arg0, float arg1, boolean arg2)",
			"fabric": "raycast(double maxDistance, float tickDelta, boolean includeFluids)"
		},
		{
			"forge": "canBeHitByProjectile()",
			"fabric": "canBeHitByProjectile()"
		},
		{
			"forge": "isPickable()",
			"fabric": "canHit()"
		},
		{
			"forge": "isPushable()",
			"fabric": "isPushable()"
		},
		{
			"forge": "awardKillScore(Entity arg0, int arg1, DamageSource arg2)",
			"fabric": "updateKilledAdvancementCriterion(Entity entityKilled, int score, DamageSource damageSource)"
		},
		{
			"forge": "shouldRender(double arg0, double arg1, double arg2)",
			"fabric": "shouldRender(double cameraX, double cameraY, double cameraZ)"
		},
		{
			"forge": "shouldRenderAtSqrDistance(double arg0)",
			"fabric": "shouldRender(double distance)"
		},
		{
			"forge": "saveAsPassenger(CompoundTag arg0)",
			"fabric": "saveSelfNbt(NbtCompound nbt)"
		},
		{
			"forge": "save(CompoundTag arg0)",
			"fabric": "saveNbt(NbtCompound nbt)"
		},
		{
			"forge": "saveWithoutId(CompoundTag arg0)",
			"fabric": "writeNbt(NbtCompound nbt)"
		},
		{
			"forge": "load(CompoundTag arg0)",
			"fabric": "readNbt(NbtCompound nbt)"
		},
		{
			"forge": "repositionEntityAfterLoad()",
			"fabric": "shouldSetPositionOnLoad()"
		},
		{
			"forge": "getEncodeId()",
			"fabric": "getSavedEntityId()"
		},
		{
			"forge": "readAdditionalSaveData(CompoundTag arg0)",
			"fabric": "readCustomDataFromNbt(NbtCompound nbt)"
		},
		{
			"forge": "addAdditionalSaveData(CompoundTag arg0)",
			"fabric": "writeCustomDataToNbt(NbtCompound nbt)"
		},
		{
			"forge": "newDoubleList(double... arg0)",
			"fabric": "toNbtList(double... values)"
		},
		{
			"forge": "newFloatList(float... arg0)",
			"fabric": "toNbtList(float... values)"
		},
		{
			"forge": "spawnAtLocation(ItemLike arg0)",
			"fabric": "dropItem(ItemConvertible item)"
		},
		{
			"forge": "spawnAtLocation(ItemLike arg0, int arg1)",
			"fabric": "dropItem(ItemConvertible item, int yOffset)"
		},
		{
			"forge": "spawnAtLocation(ItemStack arg0)",
			"fabric": "dropStack(ItemStack stack)"
		},
		{
			"forge": "spawnAtLocation(ItemStack arg0, float arg1)",
			"fabric": "dropStack(ItemStack stack, float yOffset)"
		},
		{
			"forge": "isAlive()",
			"fabric": "isAlive()"
		},
		{
			"forge": "isInWall()",
			"fabric": "isInsideWall()"
		},
		{
			"forge": "interact(Player arg0, InteractionHand arg1)",
			"fabric": "interact(PlayerEntity player, Hand hand)"
		},
		{
			"forge": "canCollideWith(Entity arg0)",
			"fabric": "collidesWith(Entity other)"
		},
		{
			"forge": "canBeCollidedWith()",
			"fabric": "isCollidable()"
		},
		{
			"forge": "rideTick()",
			"fabric": "tickRiding()"
		},
		{
			"forge": "positionRider(Entity arg0)",
			"fabric": "updatePassengerPosition(Entity passenger)"
		},
		{
			"forge": "positionRider(Entity arg0, Entity$MoveFunction arg1)",
			"fabric": "updatePassengerPosition(Entity passenger, Entity$PositionUpdater positionUpdater)"
		},
		{
			"forge": "onPassengerTurned(Entity arg0)",
			"fabric": "onPassengerLookAround(Entity passenger)"
		},
		{
			"forge": "getMyRidingOffset()",
			"fabric": "getHeightOffset()"
		},
		{
			"forge": "getPassengersRidingOffset()",
			"fabric": "getMountedHeightOffset()"
		},
		{
			"forge": "startRiding(Entity arg0)",
			"fabric": "startRiding(Entity entity)"
		},
		{
			"forge": "showVehicleHealth()",
			"fabric": "isLiving()"
		},
		{
			"forge": "startRiding(Entity arg0, boolean arg1)",
			"fabric": "startRiding(Entity entity, boolean force)"
		},
		{
			"forge": "canRide(Entity arg0)",
			"fabric": "canStartRiding(Entity entity)"
		},
		{
			"forge": "canEnterPose(Pose arg0)",
			"fabric": "wouldPoseNotCollide(EntityPose pose)"
		},
		{
			"forge": "ejectPassengers()",
			"fabric": "removeAllPassengers()"
		},
		{
			"forge": "removeVehicle()",
			"fabric": "dismountVehicle()"
		},
		{
			"forge": "stopRiding()",
			"fabric": "stopRiding()"
		},
		{
			"forge": "addPassenger(Entity arg0)",
			"fabric": "addPassenger(Entity passenger)"
		},
		{
			"forge": "removePassenger(Entity arg0)",
			"fabric": "removePassenger(Entity passenger)"
		},
		{
			"forge": "canAddPassenger(Entity arg0)",
			"fabric": "canAddPassenger(Entity passenger)"
		},
		{
			"forge": "couldAcceptPassenger()",
			"fabric": "couldAcceptPassenger()"
		},
		{
			"forge": "lerpTo(double arg0, double arg1, double arg2, float arg3, float arg4, int arg5, boolean arg6)",
			"fabric": "updateTrackedPositionAndAngles(double x, double y, double z, float yaw, float pitch, int interpolationSteps, boolean interpolate)"
		},
		{
			"forge": "lerpHeadTo(float arg0, int arg1)",
			"fabric": "updateTrackedHeadRotation(float yaw, int interpolationSteps)"
		},
		{
			"forge": "getPickRadius()",
			"fabric": "getTargetingMargin()"
		},
		{
			"forge": "getLookAngle()",
			"fabric": "getRotationVector()"
		},
		{
			"forge": "getHandHoldingItemAngle(Item arg0)",
			"fabric": "getHandPosOffset(Item item)"
		},
		{
			"forge": "getRotationVector()",
			"fabric": "getRotationClient()"
		},
		{
			"forge": "getForward()",
			"fabric": "getRotationVecClient()"
		},
		{
			"forge": "handleInsidePortal(BlockPos arg0)",
			"fabric": "setInNetherPortal(BlockPos pos)"
		},
		{
			"forge": "handleNetherPortal()",
			"fabric": "tickPortal()"
		},
		{
			"forge": "getDimensionChangingDelay()",
			"fabric": "getDefaultPortalCooldown()"
		},
		{
			"forge": "lerpMotion(double arg0, double arg1, double arg2)",
			"fabric": "setVelocityClient(double x, double y, double z)"
		},
		{
			"forge": "handleDamageEvent(DamageSource arg0)",
			"fabric": "onDamaged(DamageSource damageSource)"
		},
		{
			"forge": "handleEntityEvent(byte arg0)",
			"fabric": "handleStatus(byte status)"
		},
		{
			"forge": "animateHurt(float arg0)",
			"fabric": "animateDamage(float yaw)"
		},
		{
			"forge": "getHandSlots()",
			"fabric": "getHandItems()"
		},
		{
			"forge": "getArmorSlots()",
			"fabric": "getArmorItems()"
		},
		{
			"forge": "getAllSlots()",
			"fabric": "getItemsEquipped()"
		},
		{
			"forge": "setItemSlot(EquipmentSlot arg0, ItemStack arg1)",
			"fabric": "equipStack(EquipmentSlot slot, ItemStack stack)"
		},
		{
			"forge": "isOnFire()",
			"fabric": "isOnFire()"
		},
		{
			"forge": "isPassenger()",
			"fabric": "hasVehicle()"
		},
		{
			"forge": "isVehicle()",
			"fabric": "hasPassengers()"
		},
		{
			"forge": "dismountsUnderwater()",
			"fabric": "shouldDismountUnderwater()"
		},
		{
			"forge": "setShiftKeyDown(boolean arg0)",
			"fabric": "setSneaking(boolean sneaking)"
		},
		{
			"forge": "isShiftKeyDown()",
			"fabric": "isSneaking()"
		},
		{
			"forge": "isSteppingCarefully()",
			"fabric": "bypassesSteppingEffects()"
		},
		{
			"forge": "isSuppressingBounce()",
			"fabric": "bypassesLandingEffects()"
		},
		{
			"forge": "isDiscrete()",
			"fabric": "isSneaky()"
		},
		{
			"forge": "isDescending()",
			"fabric": "isDescending()"
		},
		{
			"forge": "isCrouching()",
			"fabric": "isInSneakingPose()"
		},
		{
			"forge": "isSprinting()",
			"fabric": "isSprinting()"
		},
		{
			"forge": "setSprinting(boolean arg0)",
			"fabric": "setSprinting(boolean sprinting)"
		},
		{
			"forge": "isSwimming()",
			"fabric": "isSwimming()"
		},
		{
			"forge": "isVisuallySwimming()",
			"fabric": "isInSwimmingPose()"
		},
		{
			"forge": "isVisuallyCrawling()",
			"fabric": "isCrawling()"
		},
		{
			"forge": "setSwimming(boolean arg0)",
			"fabric": "setSwimming(boolean swimming)"
		},
		{
			"forge": "hasGlowingTag()",
			"fabric": "isGlowingLocal()"
		},
		{
			"forge": "setGlowingTag(boolean arg0)",
			"fabric": "setGlowing(boolean glowing)"
		},
		{
			"forge": "isCurrentlyGlowing()",
			"fabric": "isGlowing()"
		},
		{
			"forge": "isInvisible()",
			"fabric": "isInvisible()"
		},
		{
			"forge": "isInvisibleTo(Player arg0)",
			"fabric": "isInvisibleTo(PlayerEntity player)"
		},
		{
			"forge": "isOnRails()",
			"fabric": "isOnRail()"
		},
		{
			"forge": "updateDynamicGameEventListener(BiConsumer<DynamicGameEventListener<?>, ServerLevel> arg0)",
			"fabric": "updateEventHandler(BiConsumer<EntityGameEventHandler<?>, ServerWorld> callback)"
		},
		{
			"forge": "getTeam()",
			"fabric": "getScoreboardTeam()"
		},
		{
			"forge": "isAlliedTo(Entity arg0)",
			"fabric": "isTeammate(Entity other)"
		},
		{
			"forge": "isAlliedTo(Team arg0)",
			"fabric": "isTeamPlayer(AbstractTeam team)"
		},
		{
			"forge": "setInvisible(boolean arg0)",
			"fabric": "setInvisible(boolean invisible)"
		},
		{
			"forge": "getSharedFlag(int arg0)",
			"fabric": "getFlag(int index)"
		},
		{
			"forge": "setSharedFlag(int arg0, boolean arg1)",
			"fabric": "setFlag(int index, boolean value)"
		},
		{
			"forge": "getMaxAirSupply()",
			"fabric": "getMaxAir()"
		},
		{
			"forge": "getAirSupply()",
			"fabric": "getAir()"
		},
		{
			"forge": "setAirSupply(int arg0)",
			"fabric": "setAir(int air)"
		},
		{
			"forge": "getTicksFrozen()",
			"fabric": "getFrozenTicks()"
		},
		{
			"forge": "setTicksFrozen(int arg0)",
			"fabric": "setFrozenTicks(int frozenTicks)"
		},
		{
			"forge": "getPercentFrozen()",
			"fabric": "getFreezingScale()"
		},
		{
			"forge": "isFullyFrozen()",
			"fabric": "isFrozen()"
		},
		{
			"forge": "getTicksRequiredToFreeze()",
			"fabric": "getMinFreezeDamageTicks()"
		},
		{
			"forge": "thunderHit(ServerLevel arg0, LightningBolt arg1)",
			"fabric": "onStruckByLightning(ServerWorld world, LightningEntity lightning)"
		},
		{
			"forge": "onAboveBubbleCol(boolean arg0)",
			"fabric": "onBubbleColumnSurfaceCollision(boolean drag)"
		},
		{
			"forge": "onInsideBubbleColumn(boolean arg0)",
			"fabric": "onBubbleColumnCollision(boolean drag)"
		},
		{
			"forge": "killedEntity(ServerLevel arg0, LivingEntity arg1)",
			"fabric": "onKilledOther(ServerWorld world, LivingEntity other)"
		},
		{
			"forge": "checkSlowFallDistance()",
			"fabric": "limitFallDistance()"
		},
		{
			"forge": "resetFallDistance()",
			"fabric": "onLanding()"
		},
		{
			"forge": "moveTowardsClosestSpace(double arg0, double arg1, double arg2)",
			"fabric": "pushOutOfBlocks(double x, double y, double z)"
		},
		{
			"forge": "makeStuckInBlock(BlockState arg0, Vec3 arg1)",
			"fabric": "slowMovement(BlockState state, Vec3d multiplier)"
		},
		{
			"forge": "removeAction(Component arg0)",
			"fabric": "removeClickEvents(Text textComponent)"
		},
		{
			"forge": "getName()",
			"fabric": "getName()"
		},
		{
			"forge": "getTypeName()",
			"fabric": "getDefaultName()"
		},
		{
			"forge": "is(Entity arg0)",
			"fabric": "isPartOf(Entity entity)"
		},
		{
			"forge": "getYHeadRot()",
			"fabric": "getHeadYaw()"
		},
		{
			"forge": "setYHeadRot(float arg0)",
			"fabric": "setHeadYaw(float headYaw)"
		},
		{
			"forge": "setYBodyRot(float arg0)",
			"fabric": "setBodyYaw(float bodyYaw)"
		},
		{
			"forge": "isAttackable()",
			"fabric": "isAttackable()"
		},
		{
			"forge": "skipAttackInteraction(Entity arg0)",
			"fabric": "handleAttack(Entity attacker)"
		},
		{
			"forge": "isInvulnerableTo(DamageSource arg0)",
			"fabric": "isInvulnerableTo(DamageSource damageSource)"
		},
		{
			"forge": "isInvulnerable()",
			"fabric": "isInvulnerable()"
		},
		{
			"forge": "setInvulnerable(boolean arg0)",
			"fabric": "setInvulnerable(boolean invulnerable)"
		},
		{
			"forge": "copyPosition(Entity arg0)",
			"fabric": "copyPositionAndRotation(Entity entity)"
		},
		{
			"forge": "restoreFrom(Entity arg0)",
			"fabric": "copyFrom(Entity original)"
		},
		{
			"forge": "changeDimension(ServerLevel arg0)",
			"fabric": "moveToWorld(ServerWorld destination)"
		},
		{
			"forge": "removeAfterChangingDimensions()",
			"fabric": "removeFromDimension()"
		},
		{
			"forge": "findDimensionEntryPoint(ServerLevel arg0)",
			"fabric": "getTeleportTarget(ServerWorld destination)"
		},
		{
			"forge": "getRelativePortalPosition(Direction$Axis arg0, BlockUtil$FoundRectangle arg1)",
			"fabric": "positionInPortal(Direction$Axis portalAxis, BlockLocating$Rectangle portalRect)"
		},
		{
			"forge": "getExitPortal(ServerLevel arg0, BlockPos arg1, boolean arg2, WorldBorder arg3)",
			"fabric": "getPortalRect(ServerWorld destWorld, BlockPos destPos, boolean destIsNether, WorldBorder worldBorder)"
		},
		{
			"forge": "canChangeDimensions()",
			"fabric": "canUsePortals()"
		},
		{
			"forge": "getBlockExplosionResistance(Explosion arg0, BlockGetter arg1, BlockPos arg2, BlockState arg3, FluidState arg4, float arg5)",
			"fabric": "getEffectiveExplosionResistance(Explosion explosion, BlockView world, BlockPos pos, BlockState blockState, FluidState fluidState, float max)"
		},
		{
			"forge": "shouldBlockExplode(Explosion arg0, BlockGetter arg1, BlockPos arg2, BlockState arg3, float arg4)",
			"fabric": "canExplosionDestroyBlock(Explosion explosion, BlockView world, BlockPos pos, BlockState state, float explosionPower)"
		},
		{
			"forge": "getMaxFallDistance()",
			"fabric": "getSafeFallDistance()"
		},
		{
			"forge": "isIgnoringBlockTriggers()",
			"fabric": "canAvoidTraps()"
		},
		{
			"forge": "fillCrashReportCategory(CrashReportCategory arg0)",
			"fabric": "populateCrashReport(CrashReportSection section)"
		},
		{
			"forge": "displayFireAnimation()",
			"fabric": "doesRenderOnFire()"
		},
		{
			"forge": "setUUID(UUID arg0)",
			"fabric": "setUuid(UUID uuid)"
		},
		{
			"forge": "getUUID()",
			"fabric": "getUuid()"
		},
		{
			"forge": "getStringUUID()",
			"fabric": "getUuidAsString()"
		},
		{
			"forge": "getScoreboardName()",
			"fabric": "getEntityName()"
		},
		{
			"forge": "isPushedByFluid()",
			"fabric": "isPushedByFluids()"
		},
		{
			"forge": "getViewScale()",
			"fabric": "getRenderDistanceMultiplier()"
		},
		{
			"forge": "setViewScale(double arg0)",
			"fabric": "setRenderDistanceMultiplier(double value)"
		},
		{
			"forge": "getDisplayName()",
			"fabric": "getDisplayName()"
		},
		{
			"forge": "setCustomName(Component arg0)",
			"fabric": "setCustomName(Text name)"
		},
		{
			"forge": "getCustomName()",
			"fabric": "getCustomName()"
		},
		{
			"forge": "hasCustomName()",
			"fabric": "hasCustomName()"
		},
		{
			"forge": "setCustomNameVisible(boolean arg0)",
			"fabric": "setCustomNameVisible(boolean visible)"
		},
		{
			"forge": "isCustomNameVisible()",
			"fabric": "isCustomNameVisible()"
		},
		{
			"forge": "teleportToWithTicket(double arg0, double arg1, double arg2)",
			"fabric": "teleport(double destX, double destY, double destZ)"
		},
		{
			"forge": "teleportTo(ServerLevel arg0, double arg1, double arg2, double arg3, Set<RelativeMovement> arg4, float arg5, float arg6)",
			"fabric": "teleport(ServerWorld world, double destX, double destY, double destZ, Set<PositionFlag> flags, float yaw, float pitch)"
		},
		{
			"forge": "dismountTo(double arg0, double arg1, double arg2)",
			"fabric": "requestTeleportAndDismount(double destX, double destY, double destZ)"
		},
		{
			"forge": "teleportTo(double arg0, double arg1, double arg2)",
			"fabric": "requestTeleport(double destX, double destY, double destZ)"
		},
		{
			"forge": "teleportPassengers()",
			"fabric": "teleportPassengers()"
		},
		{
			"forge": "teleportRelative(double arg0, double arg1, double arg2)",
			"fabric": "requestTeleportOffset(double offsetX, double offsetY, double offsetZ)"
		},
		{
			"forge": "shouldShowName()",
			"fabric": "shouldRenderName()"
		},
		{
			"forge": "onSyncedDataUpdated(List<SynchedEntityData$DataValue<?>> arg0)",
			"fabric": "onDataTrackerUpdate(List<DataTracker$SerializedEntry<?>> dataEntries)"
		},
		{
			"forge": "onSyncedDataUpdated(EntityDataAccessor<?> arg0)",
			"fabric": "onTrackedDataSet(TrackedData<?> data)"
		},
		{
			"forge": "fixupDimensions()",
			"fabric": "reinitDimensions()"
		},
		{
			"forge": "refreshDimensions()",
			"fabric": "calculateDimensions()"
		},
		{
			"forge": "getDirection()",
			"fabric": "getHorizontalFacing()"
		},
		{
			"forge": "getMotionDirection()",
			"fabric": "getMovementDirection()"
		},
		{
			"forge": "createHoverEvent()",
			"fabric": "getHoverEvent()"
		},
		{
			"forge": "broadcastToPlayer(ServerPlayer arg0)",
			"fabric": "canBeSpectated(ServerPlayerEntity spectator)"
		},
		{
			"forge": "getBoundingBox()",
			"fabric": "getBoundingBox()"
		},
		{
			"forge": "getBoundingBoxForCulling()",
			"fabric": "getVisibilityBoundingBox()"
		},
		{
			"forge": "getBoundingBoxForPose(Pose arg0)",
			"fabric": "calculateBoundsForPose(EntityPose pos)"
		},
		{
			"forge": "setBoundingBox(AABB arg0)",
			"fabric": "setBoundingBox(Box boundingBox)"
		},
		{
			"forge": "getEyeHeight(Pose arg0, EntityDimensions arg1)",
			"fabric": "getEyeHeight(EntityPose pose, EntityDimensions dimensions)"
		},
		{
			"forge": "getEyeHeight(Pose arg0)",
			"fabric": "getEyeHeight(EntityPose pose)"
		},
		{
			"forge": "getEyeHeight()",
			"fabric": "getStandingEyeHeight()"
		},
		{
			"forge": "getLeashOffset(float arg0)",
			"fabric": "getLeashOffset(float tickDelta)"
		},
		{
			"forge": "getLeashOffset()",
			"fabric": "getLeashOffset()"
		},
		{
			"forge": "getSlot(int arg0)",
			"fabric": "getStackReference(int mappedIndex)"
		},
		{
			"forge": "sendSystemMessage(Component arg0)",
			"fabric": "sendMessage(Text arg0)"
		},
		{
			"forge": "getCommandSenderWorld()",
			"fabric": "getEntityWorld()"
		},
		{
			"forge": "getServer()",
			"fabric": "getServer()"
		},
		{
			"forge": "interactAt(Player arg0, Vec3 arg1, InteractionHand arg2)",
			"fabric": "interactAt(PlayerEntity player, Vec3d hitPos, Hand hand)"
		},
		{
			"forge": "ignoreExplosion()",
			"fabric": "isImmuneToExplosion()"
		},
		{
			"forge": "doEnchantDamageEffects(LivingEntity arg0, Entity arg1)",
			"fabric": "applyDamageEffects(LivingEntity attacker, Entity target)"
		},
		{
			"forge": "startSeenByPlayer(ServerPlayer arg0)",
			"fabric": "onStartedTrackingBy(ServerPlayerEntity player)"
		},
		{
			"forge": "stopSeenByPlayer(ServerPlayer arg0)",
			"fabric": "onStoppedTrackingBy(ServerPlayerEntity player)"
		},
		{
			"forge": "rotate(Rotation arg0)",
			"fabric": "applyRotation(BlockRotation rotation)"
		},
		{
			"forge": "mirror(Mirror arg0)",
			"fabric": "applyMirror(BlockMirror mirror)"
		},
		{
			"forge": "onlyOpCanSetNbt()",
			"fabric": "entityDataRequiresOperator()"
		},
		{
			"forge": "getControllingPassenger()",
			"fabric": "getControllingPassenger()"
		},
		{
			"forge": "hasControllingPassenger()",
			"fabric": "hasControllingPassenger()"
		},
		{
			"forge": "getPassengers()",
			"fabric": "getPassengerList()"
		},
		{
			"forge": "getFirstPassenger()",
			"fabric": "getFirstPassenger()"
		},
		{
			"forge": "hasPassenger(Entity arg0)",
			"fabric": "hasPassenger(Entity passenger)"
		},
		{
			"forge": "hasPassenger(Predicate<Entity> arg0)",
			"fabric": "hasPassenger(Predicate<Entity> predicate)"
		},
		{
			"forge": "getIndirectPassengersStream()",
			"fabric": "streamIntoPassengers()"
		},
		{
			"forge": "getSelfAndPassengers()",
			"fabric": "streamSelfAndPassengers()"
		},
		{
			"forge": "getPassengersAndSelf()",
			"fabric": "streamPassengersAndSelf()"
		},
		{
			"forge": "getIndirectPassengers()",
			"fabric": "getPassengersDeep()"
		},
		{
			"forge": "hasExactlyOnePlayerPassenger()",
			"fabric": "hasPlayerRider()"
		},
		{
			"forge": "getRootVehicle()",
			"fabric": "getRootVehicle()"
		},
		{
			"forge": "isPassengerOfSameVehicle(Entity arg0)",
			"fabric": "isConnectedThroughVehicle(Entity entity)"
		},
		{
			"forge": "hasIndirectPassenger(Entity arg0)",
			"fabric": "hasPassengerDeep(Entity passenger)"
		},
		{
			"forge": "isControlledByLocalInstance()",
			"fabric": "isLogicalSideForUpdatingMovement()"
		},
		{
			"forge": "isEffectiveAi()",
			"fabric": "canMoveVoluntarily()"
		},
		{
			"forge": "getCollisionHorizontalEscapeVector(double arg0, double arg1, float arg2)",
			"fabric": "getPassengerDismountOffset(double vehicleWidth, double passengerWidth, float passengerYaw)"
		},
		{
			"forge": "getDismountLocationForPassenger(LivingEntity arg0)",
			"fabric": "updatePassengerForDismount(LivingEntity passenger)"
		},
		{
			"forge": "getVehicle()",
			"fabric": "getVehicle()"
		},
		{
			"forge": "getControlledVehicle()",
			"fabric": "getControllingVehicle()"
		},
		{
			"forge": "getPistonPushReaction()",
			"fabric": "getPistonBehavior()"
		},
		{
			"forge": "getSoundSource()",
			"fabric": "getSoundCategory()"
		},
		{
			"forge": "getFireImmuneTicks()",
			"fabric": "getBurningDuration()"
		},
		{
			"forge": "createCommandSourceStack()",
			"fabric": "getCommandSource()"
		},
		{
			"forge": "getPermissionLevel()",
			"fabric": "getPermissionLevel()"
		},
		{
			"forge": "hasPermissions(int arg0)",
			"fabric": "hasPermissionLevel(int permissionLevel)"
		},
		{
			"forge": "acceptsSuccess()",
			"fabric": "shouldReceiveFeedback()"
		},
		{
			"forge": "acceptsFailure()",
			"fabric": "shouldTrackOutput()"
		},
		{
			"forge": "shouldInformAdmins()",
			"fabric": "shouldBroadcastConsoleToOps()"
		},
		{
			"forge": "lookAt(EntityAnchorArgument$Anchor arg0, Vec3 arg1)",
			"fabric": "lookAt(EntityAnchorArgumentType$EntityAnchor anchorPoint, Vec3d target)"
		},
		{
			"forge": "updateFluidHeightAndDoFluidPushing(TagKey<Fluid> arg0, double arg1)",
			"fabric": "updateMovementInFluid(TagKey<Fluid> tag, double speed)"
		},
		{
			"forge": "touchingUnloadedChunk()",
			"fabric": "isRegionUnloaded()"
		},
		{
			"forge": "getFluidHeight(TagKey<Fluid> arg0)",
			"fabric": "getFluidHeight(TagKey<Fluid> fluid)"
		},
		{
			"forge": "getFluidJumpThreshold()",
			"fabric": "getSwimHeight()"
		},
		{
			"forge": "getBbWidth()",
			"fabric": "getWidth()"
		},
		{
			"forge": "getBbHeight()",
			"fabric": "getHeight()"
		},
		{
			"forge": "getNameTagOffsetY()",
			"fabric": "getNameLabelHeight()"
		},
		{
			"forge": "getAddEntityPacket()",
			"fabric": "createSpawnPacket()"
		},
		{
			"forge": "getDimensions(Pose arg0)",
			"fabric": "getDimensions(EntityPose pose)"
		},
		{
			"forge": "position()",
			"fabric": "getPos()"
		},
		{
			"forge": "trackingPosition()",
			"fabric": "getSyncedPos()"
		},
		{
			"forge": "blockPosition()",
			"fabric": "getBlockPos()"
		},
		{
			"forge": "getFeetBlockState()",
			"fabric": "getBlockStateAtPos()"
		},
		{
			"forge": "chunkPosition()",
			"fabric": "getChunkPos()"
		},
		{
			"forge": "getDeltaMovement()",
			"fabric": "getVelocity()"
		},
		{
			"forge": "setDeltaMovement(Vec3 arg0)",
			"fabric": "setVelocity(Vec3d velocity)"
		},
		{
			"forge": "addDeltaMovement(Vec3 arg0)",
			"fabric": "addVelocity(Vec3d velocity)"
		},
		{
			"forge": "setDeltaMovement(double arg0, double arg1, double arg2)",
			"fabric": "setVelocity(double x, double y, double z)"
		},
		{
			"forge": "getBlockX()",
			"fabric": "getBlockX()"
		},
		{
			"forge": "getX()",
			"fabric": "getX()"
		},
		{
			"forge": "getX(double arg0)",
			"fabric": "offsetX(double widthScale)"
		},
		{
			"forge": "getRandomX(double arg0)",
			"fabric": "getParticleX(double widthScale)"
		},
		{
			"forge": "getBlockY()",
			"fabric": "getBlockY()"
		},
		{
			"forge": "getY()",
			"fabric": "getY()"
		},
		{
			"forge": "getY(double arg0)",
			"fabric": "getBodyY(double heightScale)"
		},
		{
			"forge": "getRandomY()",
			"fabric": "getRandomBodyY()"
		},
		{
			"forge": "getEyeY()",
			"fabric": "getEyeY()"
		},
		{
			"forge": "getBlockZ()",
			"fabric": "getBlockZ()"
		},
		{
			"forge": "getZ()",
			"fabric": "getZ()"
		},
		{
			"forge": "getZ(double arg0)",
			"fabric": "offsetZ(double widthScale)"
		},
		{
			"forge": "getRandomZ(double arg0)",
			"fabric": "getParticleZ(double widthScale)"
		},
		{
			"forge": "setPosRaw(double arg0, double arg1, double arg2)",
			"fabric": "setPos(double x, double y, double z)"
		},
		{
			"forge": "checkDespawn()",
			"fabric": "checkDespawn()"
		},
		{
			"forge": "getRopeHoldPosition(float arg0)",
			"fabric": "getLeashPos(float delta)"
		},
		{
			"forge": "recreateFromPacket(ClientboundAddEntityPacket arg0)",
			"fabric": "onSpawnPacket(EntitySpawnS2CPacket packet)"
		},
		{
			"forge": "getPickResult()",
			"fabric": "getPickBlockStack()"
		},
		{
			"forge": "setIsInPowderSnow(boolean arg0)",
			"fabric": "setInPowderSnow(boolean inPowderSnow)"
		},
		{
			"forge": "canFreeze()",
			"fabric": "canFreeze()"
		},
		{
			"forge": "isFreezing()",
			"fabric": "shouldEscapePowderSnow()"
		},
		{
			"forge": "getYRot()",
			"fabric": "getYaw()"
		},
		{
			"forge": "getVisualRotationYInDegrees()",
			"fabric": "getBodyYaw()"
		},
		{
			"forge": "setYRot(float arg0)",
			"fabric": "setYaw(float yaw)"
		},
		{
			"forge": "getXRot()",
			"fabric": "getPitch()"
		},
		{
			"forge": "setXRot(float arg0)",
			"fabric": "setPitch(float pitch)"
		},
		{
			"forge": "canSprint()",
			"fabric": "canSprintAsVehicle()"
		},
		{
			"forge": "maxUpStep()",
			"fabric": "getStepHeight()"
		},
		{
			"forge": "setMaxUpStep(float arg0)",
			"fabric": "setStepHeight(float stepHeight)"
		},
		{
			"forge": "isRemoved()",
			"fabric": "isRemoved()"
		},
		{
			"forge": "getRemovalReason()",
			"fabric": "getRemovalReason()"
		},
		{
			"forge": "setRemoved(Entity$RemovalReason arg0)",
			"fabric": "setRemoved(Entity$RemovalReason arg0)"
		},
		{
			"forge": "unsetRemoved()",
			"fabric": "unsetRemoved()"
		},
		{
			"forge": "setLevelCallback(EntityInLevelCallback arg0)",
			"fabric": "setChangeListener(EntityChangeListener arg0)"
		},
		{
			"forge": "shouldBeSaved()",
			"fabric": "shouldSave()"
		},
		{
			"forge": "isAlwaysTicking()",
			"fabric": "isPlayer()"
		},
		{
			"forge": "mayInteract(Level arg0, BlockPos arg1)",
			"fabric": "canModifyAt(World world, BlockPos pos)"
		},
		{
			"forge": "level()",
			"fabric": "getWorld()"
		},
		{
			"forge": "setLevel(Level arg0)",
			"fabric": "setWorld(World world)"
		},
		{
			"forge": "damageSources()",
			"fabric": "getDamageSources()"
		}
	]
}