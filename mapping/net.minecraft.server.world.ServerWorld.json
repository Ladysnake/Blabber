{
	"title": "net.minecraft.server.level.ServerLevel",
	"items": [
		{
			"forge": "net.minecraft.server.level.ServerLevel",
			"fabric": "net.minecraft.server.world.ServerWorld"
		},
		{
			"forge": "END_SPAWN_POINT",
			"fabric": "END_SPAWN_POS"
		},
		{
			"forge": "END_SPAWN_POINT",
			"fabric": "END_SPAWN_POS"
		},
		{
			"forge": "RAIN_DELAY",
			"fabric": "CLEAR_WEATHER_DURATION_PROVIDER"
		},
		{
			"forge": "RAIN_DURATION",
			"fabric": "RAIN_WEATHER_DURATION_PROVIDER"
		},
		{
			"forge": "THUNDER_DELAY",
			"fabric": "CLEAR_THUNDER_WEATHER_DURATION_PROVIDER"
		},
		{
			"forge": "THUNDER_DURATION",
			"fabric": "THUNDER_WEATHER_DURATION_PROVIDER"
		},
		{
			"forge": "LOGGER",
			"fabric": "LOGGER"
		},
		{
			"forge": "EMPTY_TIME_NO_TICK",
			"fabric": "SERVER_IDLE_COOLDOWN"
		},
		{
			"forge": "MAX_SCHEDULED_TICKS_PER_TICK",
			"fabric": "MAX_TICKS"
		},
		{
			"forge": "players",
			"fabric": "players"
		},
		{
			"forge": "chunkSource",
			"fabric": "chunkManager"
		},
		{
			"forge": "server",
			"fabric": "server"
		},
		{
			"forge": "serverLevelData",
			"fabric": "worldProperties"
		},
		{
			"forge": "entityTickList",
			"fabric": "entityList"
		},
		{
			"forge": "entityManager",
			"fabric": "entityManager"
		},
		{
			"forge": "gameEventDispatcher",
			"fabric": "gameEventDispatchManager"
		},
		{
			"forge": "noSave",
			"fabric": "savingDisabled"
		},
		{
			"forge": "sleepStatus",
			"fabric": "sleepManager"
		},
		{
			"forge": "emptyTime",
			"fabric": "idleTimeout"
		},
		{
			"forge": "portalForcer",
			"fabric": "portalForcer"
		},
		{
			"forge": "blockTicks",
			"fabric": "blockTickScheduler"
		},
		{
			"forge": "fluidTicks",
			"fabric": "fluidTickScheduler"
		},
		{
			"forge": "navigatingMobs",
			"fabric": "loadedMobs"
		},
		{
			"forge": "isUpdatingNavigations",
			"fabric": "duringListenerUpdate"
		},
		{
			"forge": "raids",
			"fabric": "raidManager"
		},
		{
			"forge": "blockEvents",
			"fabric": "syncedBlockEventQueue"
		},
		{
			"forge": "blockEventsToReschedule",
			"fabric": "blockEventQueue"
		},
		{
			"forge": "handlingTick",
			"fabric": "inBlockTick"
		},
		{
			"forge": "customSpawners",
			"fabric": "spawners"
		},
		{
			"forge": "dragonFight",
			"fabric": "enderDragonFight"
		},
		{
			"forge": "dragonParts",
			"fabric": "dragonParts"
		},
		{
			"forge": "structureManager",
			"fabric": "structureAccessor"
		},
		{
			"forge": "structureCheck",
			"fabric": "structureLocator"
		},
		{
			"forge": "tickTime",
			"fabric": "shouldTickTime"
		},
		{
			"forge": "randomSequences",
			"fabric": "randomSequences"
		},
		{
			"forge": "setDragonFight(EndDragonFight arg0)",
			"fabric": "setEnderDragonFight(EnderDragonFight enderDragonFight)"
		},
		{
			"forge": "setDragonFight(EndDragonFight arg0)",
			"fabric": "setEnderDragonFight(EnderDragonFight enderDragonFight)"
		},
		{
			"forge": "setWeatherParameters(int arg0, int arg1, boolean arg2, boolean arg3)",
			"fabric": "setWeather(int clearDuration, int rainDuration, boolean raining, boolean thundering)"
		},
		{
			"forge": "getUncachedNoiseBiome(int arg0, int arg1, int arg2)",
			"fabric": "getGeneratorStoredBiome(int arg0, int arg1, int arg2)"
		},
		{
			"forge": "structureManager()",
			"fabric": "getStructureAccessor()"
		},
		{
			"forge": "tick(BooleanSupplier arg0)",
			"fabric": "tick(BooleanSupplier shouldKeepTicking)"
		},
		{
			"forge": "shouldTickBlocksAt(long arg0)",
			"fabric": "shouldTickBlocksInChunk(long arg0)"
		},
		{
			"forge": "tickTime()",
			"fabric": "tickTime()"
		},
		{
			"forge": "setDayTime(long arg0)",
			"fabric": "setTimeOfDay(long timeOfDay)"
		},
		{
			"forge": "tickCustomSpawners(boolean arg0, boolean arg1)",
			"fabric": "tickSpawners(boolean spawnMonsters, boolean spawnAnimals)"
		},
		{
			"forge": "shouldDiscardEntity(Entity arg0)",
			"fabric": "shouldCancelSpawn(Entity entity)"
		},
		{
			"forge": "wakeUpAllPlayers()",
			"fabric": "wakeSleepingPlayers()"
		},
		{
			"forge": "tickChunk(LevelChunk arg0, int arg1)",
			"fabric": "tickChunk(WorldChunk chunk, int randomTickSpeed)"
		},
		{
			"forge": "findLightningRod(BlockPos arg0)",
			"fabric": "getLightningRodPos(BlockPos pos)"
		},
		{
			"forge": "findLightningTargetAround(BlockPos arg0)",
			"fabric": "getLightningPos(BlockPos pos)"
		},
		{
			"forge": "isHandlingTick()",
			"fabric": "isInBlockTick()"
		},
		{
			"forge": "canSleepThroughNights()",
			"fabric": "isSleepingEnabled()"
		},
		{
			"forge": "announceSleepStatus()",
			"fabric": "sendSleepingStatus()"
		},
		{
			"forge": "updateSleepingPlayerList()",
			"fabric": "updateSleepingPlayers()"
		},
		{
			"forge": "getScoreboard()",
			"fabric": "getScoreboard()"
		},
		{
			"forge": "advanceWeatherCycle()",
			"fabric": "tickWeather()"
		},
		{
			"forge": "resetWeatherCycle()",
			"fabric": "resetWeather()"
		},
		{
			"forge": "resetEmptyTime()",
			"fabric": "resetIdleTimeout()"
		},
		{
			"forge": "tickFluid(BlockPos arg0, Fluid arg1)",
			"fabric": "tickFluid(BlockPos pos, Fluid fluid)"
		},
		{
			"forge": "tickBlock(BlockPos arg0, Block arg1)",
			"fabric": "tickBlock(BlockPos pos, Block block)"
		},
		{
			"forge": "tickNonPassenger(Entity arg0)",
			"fabric": "tickEntity(Entity entity)"
		},
		{
			"forge": "tickPassenger(Entity arg0, Entity arg1)",
			"fabric": "tickPassenger(Entity vehicle, Entity passenger)"
		},
		{
			"forge": "mayInteract(Player arg0, BlockPos arg1)",
			"fabric": "canPlayerModifyAt(PlayerEntity arg0, BlockPos arg1)"
		},
		{
			"forge": "save(ProgressListener arg0, boolean arg1, boolean arg2)",
			"fabric": "save(ProgressListener progressListener, boolean flush, boolean savingDisabled)"
		},
		{
			"forge": "saveLevelData()",
			"fabric": "saveLevel()"
		},
		{
			"forge": "getEntities(EntityTypeTest<Entity, T> arg0, Predicate<? super T> arg1)",
			"fabric": "getEntitiesByType(TypeFilter<Entity, T> filter, Predicate<? super T> predicate)"
		},
		{
			"forge": "getEntities(EntityTypeTest<Entity, T> arg0, Predicate<? super T> arg1, List<? super T> arg2)",
			"fabric": "collectEntitiesByType(TypeFilter<Entity, T> filter, Predicate<? super T> predicate, List<? super T> result)"
		},
		{
			"forge": "getEntities(EntityTypeTest<Entity, T> arg0, Predicate<? super T> arg1, List<? super T> arg2, int arg3)",
			"fabric": "collectEntitiesByType(TypeFilter<Entity, T> filter, Predicate<? super T> predicate, List<? super T> result, int limit)"
		},
		{
			"forge": "getDragons()",
			"fabric": "getAliveEnderDragons()"
		},
		{
			"forge": "getPlayers(Predicate<? super ServerPlayer> arg0)",
			"fabric": "getPlayers(Predicate<? super ServerPlayerEntity> predicate)"
		},
		{
			"forge": "getPlayers(Predicate<? super ServerPlayer> arg0, int arg1)",
			"fabric": "getPlayers(Predicate<? super ServerPlayerEntity> predicate, int limit)"
		},
		{
			"forge": "getRandomPlayer()",
			"fabric": "getRandomAlivePlayer()"
		},
		{
			"forge": "addFreshEntity(Entity arg0)",
			"fabric": "spawnEntity(Entity arg0)"
		},
		{
			"forge": "addWithUUID(Entity arg0)",
			"fabric": "tryLoadEntity(Entity entity)"
		},
		{
			"forge": "addDuringTeleport(Entity arg0)",
			"fabric": "onDimensionChanged(Entity entity)"
		},
		{
			"forge": "addDuringCommandTeleport(ServerPlayer arg0)",
			"fabric": "onPlayerTeleport(ServerPlayerEntity player)"
		},
		{
			"forge": "addDuringPortalTeleport(ServerPlayer arg0)",
			"fabric": "onPlayerChangeDimension(ServerPlayerEntity player)"
		},
		{
			"forge": "addNewPlayer(ServerPlayer arg0)",
			"fabric": "onPlayerConnected(ServerPlayerEntity player)"
		},
		{
			"forge": "addRespawnedPlayer(ServerPlayer arg0)",
			"fabric": "onPlayerRespawned(ServerPlayerEntity player)"
		},
		{
			"forge": "addPlayer(ServerPlayer arg0)",
			"fabric": "addPlayer(ServerPlayerEntity player)"
		},
		{
			"forge": "addEntity(Entity arg0)",
			"fabric": "addEntity(Entity entity)"
		},
		{
			"forge": "tryAddFreshEntityWithPassengers(Entity arg0)",
			"fabric": "spawnNewEntityAndPassengers(Entity entity)"
		},
		{
			"forge": "unload(LevelChunk arg0)",
			"fabric": "unloadEntities(WorldChunk chunk)"
		},
		{
			"forge": "removePlayerImmediately(ServerPlayer arg0, Entity$RemovalReason arg1)",
			"fabric": "removePlayer(ServerPlayerEntity player, Entity$RemovalReason reason)"
		},
		{
			"forge": "destroyBlockProgress(int arg0, BlockPos arg1, int arg2)",
			"fabric": "setBlockBreakingInfo(int arg0, BlockPos arg1, int arg2)"
		},
		{
			"forge": "playSeededSound(Player arg0, double arg1, double arg2, double arg3, Holder<SoundEvent> arg4, SoundSource arg5, float arg6, float arg7, long arg8)",
			"fabric": "playSound(PlayerEntity arg0, double arg1, double arg2, double arg3, RegistryEntry<SoundEvent> arg4, SoundCategory arg5, float arg6, float arg7, long arg8)"
		},
		{
			"forge": "playSeededSound(Player arg0, Entity arg1, Holder<SoundEvent> arg2, SoundSource arg3, float arg4, float arg5, long arg6)",
			"fabric": "playSoundFromEntity(PlayerEntity arg0, Entity arg1, RegistryEntry<SoundEvent> arg2, SoundCategory arg3, float arg4, float arg5, long arg6)"
		},
		{
			"forge": "globalLevelEvent(int arg0, BlockPos arg1, int arg2)",
			"fabric": "syncGlobalEvent(int arg0, BlockPos arg1, int arg2)"
		},
		{
			"forge": "levelEvent(Player arg0, int arg1, BlockPos arg2, int arg3)",
			"fabric": "syncWorldEvent(PlayerEntity arg0, int arg1, BlockPos arg2, int arg3)"
		},
		{
			"forge": "getLogicalHeight()",
			"fabric": "getLogicalHeight()"
		},
		{
			"forge": "gameEvent(GameEvent arg0, Vec3 arg1, GameEvent$Context arg2)",
			"fabric": "emitGameEvent(GameEvent arg0, Vec3d arg1, GameEvent$Emitter arg2)"
		},
		{
			"forge": "sendBlockUpdated(BlockPos arg0, BlockState arg1, BlockState arg2, int arg3)",
			"fabric": "updateListeners(BlockPos arg0, BlockState arg1, BlockState arg2, int arg3)"
		},
		{
			"forge": "updateNeighborsAt(BlockPos arg0, Block arg1)",
			"fabric": "updateNeighborsAlways(BlockPos arg0, Block arg1)"
		},
		{
			"forge": "updateNeighborsAtExceptFromFacing(BlockPos arg0, Block arg1, Direction arg2)",
			"fabric": "updateNeighborsExcept(BlockPos arg0, Block arg1, Direction arg2)"
		},
		{
			"forge": "neighborChanged(BlockPos arg0, Block arg1, BlockPos arg2)",
			"fabric": "updateNeighbor(BlockPos arg0, Block arg1, BlockPos arg2)"
		},
		{
			"forge": "neighborChanged(BlockState arg0, BlockPos arg1, Block arg2, BlockPos arg3, boolean arg4)",
			"fabric": "updateNeighbor(BlockState arg0, BlockPos arg1, Block arg2, BlockPos arg3, boolean arg4)"
		},
		{
			"forge": "broadcastEntityEvent(Entity arg0, byte arg1)",
			"fabric": "sendEntityStatus(Entity arg0, byte arg1)"
		},
		{
			"forge": "broadcastDamageEvent(Entity arg0, DamageSource arg1)",
			"fabric": "sendEntityDamage(Entity arg0, DamageSource arg1)"
		},
		{
			"forge": "getChunkSource()",
			"fabric": "getChunkManager()"
		},
		{
			"forge": "explode(Entity arg0, DamageSource arg1, ExplosionDamageCalculator arg2, double arg3, double arg4, double arg5, float arg6, boolean arg7, Level$ExplosionInteraction arg8)",
			"fabric": "createExplosion(Entity arg0, DamageSource arg1, ExplosionBehavior arg2, double arg3, double arg4, double arg5, float arg6, boolean arg7, World$ExplosionSourceType arg8)"
		},
		{
			"forge": "blockEvent(BlockPos arg0, Block arg1, int arg2, int arg3)",
			"fabric": "addSyncedBlockEvent(BlockPos arg0, Block arg1, int arg2, int arg3)"
		},
		{
			"forge": "runBlockEvents()",
			"fabric": "processSyncedBlockEvents()"
		},
		{
			"forge": "doBlockEvent(BlockEventData arg0)",
			"fabric": "processBlockEvent(BlockEvent event)"
		},
		{
			"forge": "getBlockTicks()",
			"fabric": "getBlockTickScheduler()"
		},
		{
			"forge": "getFluidTicks()",
			"fabric": "getFluidTickScheduler()"
		},
		{
			"forge": "getServer()",
			"fabric": "getServer()"
		},
		{
			"forge": "getPortalForcer()",
			"fabric": "getPortalForcer()"
		},
		{
			"forge": "getStructureManager()",
			"fabric": "getStructureTemplateManager()"
		},
		{
			"forge": "sendParticles(T arg0, double arg1, double arg2, double arg3, int arg4, double arg5, double arg6, double arg7, double arg8)",
			"fabric": "spawnParticles(T particle, double x, double y, double z, int count, double deltaX, double deltaY, double deltaZ, double speed)"
		},
		{
			"forge": "sendParticles(ServerPlayer arg0, T arg1, boolean arg2, double arg3, double arg4, double arg5, int arg6, double arg7, double arg8, double arg9, double arg10)",
			"fabric": "spawnParticles(ServerPlayerEntity viewer, T particle, boolean force, double x, double y, double z, int count, double deltaX, double deltaY, double deltaZ, double speed)"
		},
		{
			"forge": "sendParticles(ServerPlayer arg0, boolean arg1, double arg2, double arg3, double arg4, Packet<?> arg5)",
			"fabric": "sendToPlayerIfNearby(ServerPlayerEntity player, boolean force, double x, double y, double z, Packet<?> packet)"
		},
		{
			"forge": "getEntity(int arg0)",
			"fabric": "getEntityById(int arg0)"
		},
		{
			"forge": "getEntityOrPart(int arg0)",
			"fabric": "getDragonPart(int id)"
		},
		{
			"forge": "getEntity(UUID arg0)",
			"fabric": "getEntity(UUID uuid)"
		},
		{
			"forge": "findNearestMapStructure(TagKey<Structure> arg0, BlockPos arg1, int arg2, boolean arg3)",
			"fabric": "locateStructure(TagKey<Structure> structureTag, BlockPos pos, int radius, boolean skipReferencedStructures)"
		},
		{
			"forge": "findClosestBiome3d(Predicate<Holder<Biome>> arg0, BlockPos arg1, int arg2, int arg3, int arg4)",
			"fabric": "locateBiome(Predicate<RegistryEntry<Biome>> predicate, BlockPos pos, int radius, int horizontalBlockCheckInterval, int verticalBlockCheckInterval)"
		},
		{
			"forge": "getRecipeManager()",
			"fabric": "getRecipeManager()"
		},
		{
			"forge": "noSave()",
			"fabric": "isSavingDisabled()"
		},
		{
			"forge": "getDataStorage()",
			"fabric": "getPersistentStateManager()"
		},
		{
			"forge": "getMapData(String arg0)",
			"fabric": "getMapState(String arg0)"
		},
		{
			"forge": "setMapData(String arg0, MapItemSavedData arg1)",
			"fabric": "putMapState(String arg0, MapState arg1)"
		},
		{
			"forge": "getFreeMapId()",
			"fabric": "getNextMapId()"
		},
		{
			"forge": "setDefaultSpawnPos(BlockPos arg0, float arg1)",
			"fabric": "setSpawnPos(BlockPos pos, float angle)"
		},
		{
			"forge": "getForcedChunks()",
			"fabric": "getForcedChunks()"
		},
		{
			"forge": "setChunkForced(int arg0, int arg1, boolean arg2)",
			"fabric": "setChunkForced(int x, int z, boolean forced)"
		},
		{
			"forge": "players()",
			"fabric": "getPlayers()"
		},
		{
			"forge": "onBlockStateChange(BlockPos arg0, BlockState arg1, BlockState arg2)",
			"fabric": "onBlockChanged(BlockPos arg0, BlockState arg1, BlockState arg2)"
		},
		{
			"forge": "getPoiManager()",
			"fabric": "getPointOfInterestStorage()"
		},
		{
			"forge": "isVillage(BlockPos arg0)",
			"fabric": "isNearOccupiedPointOfInterest(BlockPos pos)"
		},
		{
			"forge": "isVillage(SectionPos arg0)",
			"fabric": "isNearOccupiedPointOfInterest(ChunkSectionPos sectionPos)"
		},
		{
			"forge": "isCloseToVillage(BlockPos arg0, int arg1)",
			"fabric": "isNearOccupiedPointOfInterest(BlockPos pos, int maxDistance)"
		},
		{
			"forge": "sectionsToVillage(SectionPos arg0)",
			"fabric": "getOccupiedPointOfInterestDistance(ChunkSectionPos pos)"
		},
		{
			"forge": "getRaids()",
			"fabric": "getRaidManager()"
		},
		{
			"forge": "getRaidAt(BlockPos arg0)",
			"fabric": "getRaidAt(BlockPos pos)"
		},
		{
			"forge": "isRaided(BlockPos arg0)",
			"fabric": "hasRaidAt(BlockPos pos)"
		},
		{
			"forge": "onReputationEvent(ReputationEventType arg0, Entity arg1, ReputationEventHandler arg2)",
			"fabric": "handleInteraction(EntityInteraction interaction, Entity entity, InteractionObserver observer)"
		},
		{
			"forge": "saveDebugReport(Path arg0)",
			"fabric": "dump(Path path)"
		},
		{
			"forge": "dumpEntities(Writer arg0, Iterable<Entity> arg1)",
			"fabric": "dumpEntities(Writer writer, Iterable<Entity> entities)"
		},
		{
			"forge": "dumpBlockEntityTickers(Writer arg0)",
			"fabric": "dumpBlockEntities(Writer writer)"
		},
		{
			"forge": "clearBlockEvents(BoundingBox arg0)",
			"fabric": "clearUpdatesInArea(BlockBox box)"
		},
		{
			"forge": "blockUpdated(BlockPos arg0, Block arg1)",
			"fabric": "updateNeighbors(BlockPos arg0, Block arg1)"
		},
		{
			"forge": "getShade(Direction arg0, boolean arg1)",
			"fabric": "getBrightness(Direction arg0, boolean arg1)"
		},
		{
			"forge": "getAllEntities()",
			"fabric": "iterateEntities()"
		},
		{
			"forge": "isFlat()",
			"fabric": "isFlat()"
		},
		{
			"forge": "getSeed()",
			"fabric": "getSeed()"
		},
		{
			"forge": "getDragonFight()",
			"fabric": "getEnderDragonFight()"
		},
		{
			"forge": "getLevel()",
			"fabric": "toServerWorld()"
		},
		{
			"forge": "getWatchdogStats()",
			"fabric": "getDebugString()"
		},
		{
			"forge": "getTypeCount(Iterable<T> arg0, Function<T, String> arg1)",
			"fabric": "getTopFive(Iterable<T> items, Function<T, String> classifier)"
		},
		{
			"forge": "makeObsidianPlatform(ServerLevel arg0)",
			"fabric": "createEndSpawnPlatform(ServerWorld world)"
		},
		{
			"forge": "getEntities()",
			"fabric": "getEntityLookup()"
		},
		{
			"forge": "addLegacyChunkEntities(Stream<Entity> arg0)",
			"fabric": "loadEntities(Stream<Entity> entities)"
		},
		{
			"forge": "addWorldGenChunkEntities(Stream<Entity> arg0)",
			"fabric": "addEntities(Stream<Entity> entities)"
		},
		{
			"forge": "startTickingChunk(LevelChunk arg0)",
			"fabric": "disableTickSchedulers(WorldChunk chunk)"
		},
		{
			"forge": "onStructureStartsAvailable(ChunkAccess arg0)",
			"fabric": "cacheStructures(Chunk chunk)"
		},
		{
			"forge": "gatherChunkSourceStats()",
			"fabric": "asString()"
		},
		{
			"forge": "areEntitiesLoaded(long arg0)",
			"fabric": "isChunkLoaded(long chunkPos)"
		},
		{
			"forge": "isPositionTickingWithEntitiesLoaded(long arg0)",
			"fabric": "isTickingFutureReady(long chunkPos)"
		},
		{
			"forge": "isPositionEntityTicking(BlockPos arg0)",
			"fabric": "shouldTickEntity(BlockPos pos)"
		},
		{
			"forge": "isNaturalSpawningAllowed(BlockPos arg0)",
			"fabric": "shouldTick(BlockPos pos)"
		},
		{
			"forge": "isNaturalSpawningAllowed(ChunkPos arg0)",
			"fabric": "shouldTick(ChunkPos pos)"
		},
		{
			"forge": "enabledFeatures()",
			"fabric": "getEnabledFeatures()"
		},
		{
			"forge": "getRandomSequence(ResourceLocation arg0)",
			"fabric": "getOrCreateRandom(Identifier id)"
		},
		{
			"forge": "getRandomSequences()",
			"fabric": "getRandomSequences()"
		}
	]
}