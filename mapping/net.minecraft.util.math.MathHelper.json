{
	"title": "net.minecraft.util.Mth",
	"items": [
		{
			"forge": "net.minecraft.util.Mth",
			"fabric": "net.minecraft.util.math.MathHelper"
		},
		{
			"forge": "UUID_VERSION",
			"fabric": "field_29852"
		},
		{
			"forge": "UUID_VERSION",
			"fabric": "field_29852"
		},
		{
			"forge": "UUID_VERSION_TYPE_4",
			"fabric": "HALF_PI_RADIANS_SINE_TABLE_INDEX"
		},
		{
			"forge": "UUID_VARIANT",
			"fabric": "field_29854"
		},
		{
			"forge": "UUID_VARIANT_2",
			"fabric": "field_29855"
		},
		{
			"forge": "PI",
			"fabric": "PI"
		},
		{
			"forge": "HALF_PI",
			"fabric": "HALF_PI"
		},
		{
			"forge": "TWO_PI",
			"fabric": "TAU"
		},
		{
			"forge": "DEG_TO_RAD",
			"fabric": "RADIANS_PER_DEGREE"
		},
		{
			"forge": "RAD_TO_DEG",
			"fabric": "DEGREES_PER_RADIAN"
		},
		{
			"forge": "EPSILON",
			"fabric": "EPSILON"
		},
		{
			"forge": "SQRT_OF_TWO",
			"fabric": "SQUARE_ROOT_OF_TWO"
		},
		{
			"forge": "SIN_SCALE",
			"fabric": "DEGREES_TO_SINE_TABLE_INDEX"
		},
		{
			"forge": "SIN",
			"fabric": "SINE_TABLE"
		},
		{
			"forge": "RANDOM",
			"fabric": "RANDOM"
		},
		{
			"forge": "MULTIPLY_DE_BRUIJN_BIT_POSITION",
			"fabric": "MULTIPLY_DE_BRUIJN_BIT_POSITION"
		},
		{
			"forge": "ONE_SIXTH",
			"fabric": "ARCSINE_MACLAURIN_3"
		},
		{
			"forge": "FRAC_EXP",
			"fabric": "field_29858"
		},
		{
			"forge": "LUT_SIZE",
			"fabric": "ARCSINE_TABLE_LENGTH"
		},
		{
			"forge": "FRAC_BIAS",
			"fabric": "ROUNDER_256THS"
		},
		{
			"forge": "ASIN_TAB",
			"fabric": "ARCSINE_TABLE"
		},
		{
			"forge": "COS_TAB",
			"fabric": "COSINE_OF_ARCSINE_TABLE"
		},
		{
			"forge": "sin(float arg0)",
			"fabric": "sin(float value)"
		},
		{
			"forge": "sin(float arg0)",
			"fabric": "sin(float value)"
		},
		{
			"forge": "cos(float arg0)",
			"fabric": "cos(float value)"
		},
		{
			"forge": "sqrt(float arg0)",
			"fabric": "sqrt(float value)"
		},
		{
			"forge": "floor(float arg0)",
			"fabric": "floor(float value)"
		},
		{
			"forge": "floor(double arg0)",
			"fabric": "floor(double value)"
		},
		{
			"forge": "lfloor(double arg0)",
			"fabric": "lfloor(double value)"
		},
		{
			"forge": "abs(float arg0)",
			"fabric": "abs(float value)"
		},
		{
			"forge": "abs(int arg0)",
			"fabric": "abs(int value)"
		},
		{
			"forge": "ceil(float arg0)",
			"fabric": "ceil(float value)"
		},
		{
			"forge": "ceil(double arg0)",
			"fabric": "ceil(double value)"
		},
		{
			"forge": "clamp(int arg0, int arg1, int arg2)",
			"fabric": "clamp(int value, int min, int max)"
		},
		{
			"forge": "clamp(float arg0, float arg1, float arg2)",
			"fabric": "clamp(float value, float min, float max)"
		},
		{
			"forge": "clamp(double arg0, double arg1, double arg2)",
			"fabric": "clamp(double value, double min, double max)"
		},
		{
			"forge": "clampedLerp(double arg0, double arg1, double arg2)",
			"fabric": "clampedLerp(double start, double end, double delta)"
		},
		{
			"forge": "clampedLerp(float arg0, float arg1, float arg2)",
			"fabric": "clampedLerp(float start, float end, float delta)"
		},
		{
			"forge": "absMax(double arg0, double arg1)",
			"fabric": "absMax(double a, double b)"
		},
		{
			"forge": "floorDiv(int arg0, int arg1)",
			"fabric": "floorDiv(int dividend, int divisor)"
		},
		{
			"forge": "nextInt(RandomSource arg0, int arg1, int arg2)",
			"fabric": "nextInt(Random random, int min, int max)"
		},
		{
			"forge": "nextFloat(RandomSource arg0, float arg1, float arg2)",
			"fabric": "nextFloat(Random random, float min, float max)"
		},
		{
			"forge": "nextDouble(RandomSource arg0, double arg1, double arg2)",
			"fabric": "nextDouble(Random random, double min, double max)"
		},
		{
			"forge": "equal(float arg0, float arg1)",
			"fabric": "approximatelyEquals(float a, float b)"
		},
		{
			"forge": "equal(double arg0, double arg1)",
			"fabric": "approximatelyEquals(double a, double b)"
		},
		{
			"forge": "positiveModulo(int arg0, int arg1)",
			"fabric": "floorMod(int dividend, int divisor)"
		},
		{
			"forge": "positiveModulo(float arg0, float arg1)",
			"fabric": "floorMod(float dividend, float divisor)"
		},
		{
			"forge": "positiveModulo(double arg0, double arg1)",
			"fabric": "floorMod(double dividend, double divisor)"
		},
		{
			"forge": "isMultipleOf(int arg0, int arg1)",
			"fabric": "isMultipleOf(int a, int b)"
		},
		{
			"forge": "wrapDegrees(int arg0)",
			"fabric": "wrapDegrees(int degrees)"
		},
		{
			"forge": "wrapDegrees(float arg0)",
			"fabric": "wrapDegrees(float degrees)"
		},
		{
			"forge": "wrapDegrees(double arg0)",
			"fabric": "wrapDegrees(double degrees)"
		},
		{
			"forge": "degreesDifference(float arg0, float arg1)",
			"fabric": "subtractAngles(float start, float end)"
		},
		{
			"forge": "degreesDifferenceAbs(float arg0, float arg1)",
			"fabric": "angleBetween(float first, float second)"
		},
		{
			"forge": "rotateIfNecessary(float arg0, float arg1, float arg2)",
			"fabric": "clampAngle(float value, float mean, float delta)"
		},
		{
			"forge": "approach(float arg0, float arg1, float arg2)",
			"fabric": "stepTowards(float from, float to, float step)"
		},
		{
			"forge": "approachDegrees(float arg0, float arg1, float arg2)",
			"fabric": "stepUnwrappedAngleTowards(float from, float to, float step)"
		},
		{
			"forge": "getInt(String arg0, int arg1)",
			"fabric": "parseInt(String string, int fallback)"
		},
		{
			"forge": "smallestEncompassingPowerOfTwo(int arg0)",
			"fabric": "smallestEncompassingPowerOfTwo(int value)"
		},
		{
			"forge": "isPowerOfTwo(int arg0)",
			"fabric": "isPowerOfTwo(int value)"
		},
		{
			"forge": "ceillog2(int arg0)",
			"fabric": "ceilLog2(int value)"
		},
		{
			"forge": "log2(int arg0)",
			"fabric": "floorLog2(int value)"
		},
		{
			"forge": "color(float arg0, float arg1, float arg2)",
			"fabric": "packRgb(float r, float g, float b)"
		},
		{
			"forge": "frac(float arg0)",
			"fabric": "fractionalPart(float value)"
		},
		{
			"forge": "frac(double arg0)",
			"fabric": "fractionalPart(double value)"
		},
		{
			"forge": "getSeed(Vec3i arg0)",
			"fabric": "hashCode(Vec3i vec)"
		},
		{
			"forge": "getSeed(int arg0, int arg1, int arg2)",
			"fabric": "hashCode(int x, int y, int z)"
		},
		{
			"forge": "createInsecureUUID(RandomSource arg0)",
			"fabric": "randomUuid(Random random)"
		},
		{
			"forge": "createInsecureUUID()",
			"fabric": "randomUuid()"
		},
		{
			"forge": "inverseLerp(double arg0, double arg1, double arg2)",
			"fabric": "getLerpProgress(double value, double start, double end)"
		},
		{
			"forge": "inverseLerp(float arg0, float arg1, float arg2)",
			"fabric": "getLerpProgress(float value, float start, float end)"
		},
		{
			"forge": "rayIntersectsAABB(Vec3 arg0, Vec3 arg1, AABB arg2)",
			"fabric": "method_34945(Vec3d origin, Vec3d direction, Box box)"
		},
		{
			"forge": "atan2(double arg0, double arg1)",
			"fabric": "atan2(double y, double x)"
		},
		{
			"forge": "invSqrt(float arg0)",
			"fabric": "inverseSqrt(float x)"
		},
		{
			"forge": "invSqrt(double arg0)",
			"fabric": "inverseSqrt(double x)"
		},
		{
			"forge": "fastInvSqrt(double arg0)",
			"fabric": "fastInverseSqrt(double x)"
		},
		{
			"forge": "fastInvCubeRoot(float arg0)",
			"fabric": "fastInverseCbrt(float x)"
		},
		{
			"forge": "hsvToRgb(float arg0, float arg1, float arg2)",
			"fabric": "hsvToRgb(float hue, float saturation, float value)"
		},
		{
			"forge": "murmurHash3Mixer(int arg0)",
			"fabric": "idealHash(int value)"
		},
		{
			"forge": "binarySearch(int arg0, int arg1, IntPredicate arg2)",
			"fabric": "binarySearch(int min, int max, IntPredicate predicate)"
		},
		{
			"forge": "lerpInt(float arg0, int arg1, int arg2)",
			"fabric": "lerp(float delta, int start, int end)"
		},
		{
			"forge": "lerp(float arg0, float arg1, float arg2)",
			"fabric": "lerp(float delta, float start, float end)"
		},
		{
			"forge": "lerp(double arg0, double arg1, double arg2)",
			"fabric": "lerp(double delta, double start, double end)"
		},
		{
			"forge": "lerp2(double arg0, double arg1, double arg2, double arg3, double arg4, double arg5)",
			"fabric": "lerp2(double deltaX, double deltaY, double x0y0, double x1y0, double x0y1, double x1y1)"
		},
		{
			"forge": "lerp3(double arg0, double arg1, double arg2, double arg3, double arg4, double arg5, double arg6, double arg7, double arg8, double arg9, double arg10)",
			"fabric": "lerp3(double deltaX, double deltaY, double deltaZ, double x0y0z0, double x1y0z0, double x0y1z0, double x1y1z0, double x0y0z1, double x1y0z1, double x0y1z1, double x1y1z1)"
		},
		{
			"forge": "catmullrom(float arg0, float arg1, float arg2, float arg3, float arg4)",
			"fabric": "catmullRom(float delta, float p0, float p1, float p2, float p3)"
		},
		{
			"forge": "smoothstep(double arg0)",
			"fabric": "perlinFade(double value)"
		},
		{
			"forge": "smoothstepDerivative(double arg0)",
			"fabric": "perlinFadeDerivative(double value)"
		},
		{
			"forge": "sign(double arg0)",
			"fabric": "sign(double value)"
		},
		{
			"forge": "rotLerp(float arg0, float arg1, float arg2)",
			"fabric": "lerpAngleDegrees(float delta, float start, float end)"
		},
		{
			"forge": "triangleWave(float arg0, float arg1)",
			"fabric": "wrap(float value, float maxDeviation)"
		},
		{
			"forge": "square(float arg0)",
			"fabric": "square(float n)"
		},
		{
			"forge": "square(double arg0)",
			"fabric": "square(double n)"
		},
		{
			"forge": "square(int arg0)",
			"fabric": "square(int n)"
		},
		{
			"forge": "square(long arg0)",
			"fabric": "square(long n)"
		},
		{
			"forge": "clampedMap(double arg0, double arg1, double arg2, double arg3, double arg4)",
			"fabric": "clampedMap(double value, double oldStart, double oldEnd, double newStart, double newEnd)"
		},
		{
			"forge": "clampedMap(float arg0, float arg1, float arg2, float arg3, float arg4)",
			"fabric": "clampedMap(float value, float oldStart, float oldEnd, float newStart, float newEnd)"
		},
		{
			"forge": "map(double arg0, double arg1, double arg2, double arg3, double arg4)",
			"fabric": "map(double value, double oldStart, double oldEnd, double newStart, double newEnd)"
		},
		{
			"forge": "map(float arg0, float arg1, float arg2, float arg3, float arg4)",
			"fabric": "map(float value, float oldStart, float oldEnd, float newStart, float newEnd)"
		},
		{
			"forge": "wobble(double arg0)",
			"fabric": "method_34957(double arg0)"
		},
		{
			"forge": "roundToward(int arg0, int arg1)",
			"fabric": "roundUpToMultiple(int value, int divisor)"
		},
		{
			"forge": "positiveCeilDiv(int arg0, int arg1)",
			"fabric": "ceilDiv(int a, int b)"
		},
		{
			"forge": "randomBetweenInclusive(RandomSource arg0, int arg1, int arg2)",
			"fabric": "nextBetween(Random random, int min, int max)"
		},
		{
			"forge": "randomBetween(RandomSource arg0, float arg1, float arg2)",
			"fabric": "nextBetween(Random random, float min, float max)"
		},
		{
			"forge": "normal(RandomSource arg0, float arg1, float arg2)",
			"fabric": "nextGaussian(Random random, float mean, float deviation)"
		},
		{
			"forge": "lengthSquared(double arg0, double arg1)",
			"fabric": "squaredHypot(double a, double b)"
		},
		{
			"forge": "length(double arg0, double arg1)",
			"fabric": "hypot(double a, double b)"
		},
		{
			"forge": "lengthSquared(double arg0, double arg1, double arg2)",
			"fabric": "squaredMagnitude(double a, double b, double c)"
		},
		{
			"forge": "length(double arg0, double arg1, double arg2)",
			"fabric": "magnitude(double a, double b, double c)"
		},
		{
			"forge": "quantize(double arg0, int arg1)",
			"fabric": "roundDownToMultiple(double a, int b)"
		},
		{
			"forge": "outFromOrigin(int arg0, int arg1, int arg2)",
			"fabric": "stream(int seed, int lowerBound, int upperBound)"
		},
		{
			"forge": "outFromOrigin(int arg0, int arg1, int arg2, int arg3)",
			"fabric": "stream(int seed, int lowerBound, int upperBound, int steps)"
		}
	]
}