{
	"title": "net.minecraft.gametest.framework.GameTestHelper",
	"items": [
		{
			"forge": "net.minecraft.gametest.framework.GameTestHelper",
			"fabric": "net.minecraft.test.TestContext"
		},
		{
			"forge": "testInfo",
			"fabric": "test"
		},
		{
			"forge": "testInfo",
			"fabric": "test"
		},
		{
			"forge": "finalCheckAdded",
			"fabric": "hasFinalClause"
		},
		{
			"forge": "getLevel()",
			"fabric": "getWorld()"
		},
		{
			"forge": "getLevel()",
			"fabric": "getWorld()"
		},
		{
			"forge": "getBlockState(BlockPos arg0)",
			"fabric": "getBlockState(BlockPos pos)"
		},
		{
			"forge": "getBlockEntity(BlockPos arg0)",
			"fabric": "getBlockEntity(BlockPos pos)"
		},
		{
			"forge": "killAllEntities()",
			"fabric": "killAllEntities()"
		},
		{
			"forge": "killAllEntitiesOfClass(Class arg0)",
			"fabric": "killAllEntities(Class entityClass)"
		},
		{
			"forge": "spawnItem(Item arg0, float arg1, float arg2, float arg3)",
			"fabric": "spawnItem(Item item, float x, float y, float z)"
		},
		{
			"forge": "spawnItem(Item arg0, BlockPos arg1)",
			"fabric": "spawnItem(Item item, BlockPos pos)"
		},
		{
			"forge": "spawn(EntityType<E> arg0, BlockPos arg1)",
			"fabric": "spawnEntity(EntityType<E> type, BlockPos pos)"
		},
		{
			"forge": "spawn(EntityType<E> arg0, Vec3 arg1)",
			"fabric": "spawnEntity(EntityType<E> type, Vec3d pos)"
		},
		{
			"forge": "spawn(EntityType<E> arg0, int arg1, int arg2, int arg3)",
			"fabric": "spawnEntity(EntityType<E> type, int x, int y, int z)"
		},
		{
			"forge": "spawn(EntityType<E> arg0, float arg1, float arg2, float arg3)",
			"fabric": "spawnEntity(EntityType<E> type, float x, float y, float z)"
		},
		{
			"forge": "spawnWithNoFreeWill(EntityType<E> arg0, BlockPos arg1)",
			"fabric": "spawnMob(EntityType<E> type, BlockPos pos)"
		},
		{
			"forge": "spawnWithNoFreeWill(EntityType<E> arg0, int arg1, int arg2, int arg3)",
			"fabric": "spawnMob(EntityType<E> type, int x, int y, int z)"
		},
		{
			"forge": "spawnWithNoFreeWill(EntityType<E> arg0, Vec3 arg1)",
			"fabric": "spawnMob(EntityType<E> type, Vec3d pos)"
		},
		{
			"forge": "spawnWithNoFreeWill(EntityType<E> arg0, float arg1, float arg2, float arg3)",
			"fabric": "spawnMob(EntityType<E> type, float x, float y, float z)"
		},
		{
			"forge": "walkTo(Mob arg0, BlockPos arg1, float arg2)",
			"fabric": "startMovingTowards(MobEntity entity, BlockPos pos, float speed)"
		},
		{
			"forge": "pressButton(int arg0, int arg1, int arg2)",
			"fabric": "pushButton(int x, int y, int z)"
		},
		{
			"forge": "pressButton(BlockPos arg0)",
			"fabric": "pushButton(BlockPos pos)"
		},
		{
			"forge": "useBlock(BlockPos arg0)",
			"fabric": "useBlock(BlockPos pos)"
		},
		{
			"forge": "useBlock(BlockPos arg0, Player arg1)",
			"fabric": "useBlock(BlockPos pos, PlayerEntity player)"
		},
		{
			"forge": "useBlock(BlockPos arg0, Player arg1, BlockHitResult arg2)",
			"fabric": "useBlock(BlockPos pos, PlayerEntity player, BlockHitResult result)"
		},
		{
			"forge": "makeAboutToDrown(LivingEntity arg0)",
			"fabric": "drown(LivingEntity entity)"
		},
		{
			"forge": "makeMockSurvivalPlayer()",
			"fabric": "createMockSurvivalPlayer()"
		},
		{
			"forge": "withLowHealth(LivingEntity arg0)",
			"fabric": "setHealthLow(LivingEntity entity)"
		},
		{
			"forge": "makeMockPlayer()",
			"fabric": "createMockCreativePlayer()"
		},
		{
			"forge": "makeMockServerPlayerInLevel()",
			"fabric": "createMockCreativeServerPlayerInWorld()"
		},
		{
			"forge": "pullLever(int arg0, int arg1, int arg2)",
			"fabric": "toggleLever(int x, int y, int z)"
		},
		{
			"forge": "pullLever(BlockPos arg0)",
			"fabric": "toggleLever(BlockPos pos)"
		},
		{
			"forge": "pulseRedstone(BlockPos arg0, long arg1)",
			"fabric": "putAndRemoveRedstoneBlock(BlockPos pos, long delay)"
		},
		{
			"forge": "destroyBlock(BlockPos arg0)",
			"fabric": "removeBlock(BlockPos pos)"
		},
		{
			"forge": "setBlock(int arg0, int arg1, int arg2, Block arg3)",
			"fabric": "setBlockState(int x, int y, int z, Block block)"
		},
		{
			"forge": "setBlock(int arg0, int arg1, int arg2, BlockState arg3)",
			"fabric": "setBlockState(int x, int y, int z, BlockState state)"
		},
		{
			"forge": "setBlock(BlockPos arg0, Block arg1)",
			"fabric": "setBlockState(BlockPos pos, Block block)"
		},
		{
			"forge": "setBlock(BlockPos arg0, BlockState arg1)",
			"fabric": "setBlockState(BlockPos pos, BlockState state)"
		},
		{
			"forge": "setNight()",
			"fabric": "useNightTime()"
		},
		{
			"forge": "setDayTime(int arg0)",
			"fabric": "setTime(int timeOfDay)"
		},
		{
			"forge": "assertBlockPresent(Block arg0, int arg1, int arg2, int arg3)",
			"fabric": "expectBlock(Block block, int x, int y, int z)"
		},
		{
			"forge": "assertBlockPresent(Block arg0, BlockPos arg1)",
			"fabric": "expectBlock(Block block, BlockPos pos)"
		},
		{
			"forge": "assertBlockNotPresent(Block arg0, int arg1, int arg2, int arg3)",
			"fabric": "dontExpectBlock(Block block, int x, int y, int z)"
		},
		{
			"forge": "assertBlockNotPresent(Block arg0, BlockPos arg1)",
			"fabric": "dontExpectBlock(Block block, BlockPos pos)"
		},
		{
			"forge": "succeedWhenBlockPresent(Block arg0, int arg1, int arg2, int arg3)",
			"fabric": "expectBlockAtEnd(Block block, int x, int y, int z)"
		},
		{
			"forge": "succeedWhenBlockPresent(Block arg0, BlockPos arg1)",
			"fabric": "expectBlockAtEnd(Block block, BlockPos pos)"
		},
		{
			"forge": "assertBlock(BlockPos arg0, Predicate<Block> arg1, String arg2)",
			"fabric": "checkBlock(BlockPos pos, Predicate<Block> predicate, String errorMessage)"
		},
		{
			"forge": "assertBlock(BlockPos arg0, Predicate<Block> arg1, Supplier<String> arg2)",
			"fabric": "checkBlock(BlockPos pos, Predicate<Block> predicate, Supplier<String> errorMessageSupplier)"
		},
		{
			"forge": "assertBlockProperty(BlockPos arg0, Property<T> arg1, T arg2)",
			"fabric": "expectBlockProperty(BlockPos pos, Property<T> property, T value)"
		},
		{
			"forge": "assertBlockProperty(BlockPos arg0, Property<T> arg1, Predicate<T> arg2, String arg3)",
			"fabric": "checkBlockProperty(BlockPos pos, Property<T> property, Predicate<T> predicate, String errorMessage)"
		},
		{
			"forge": "assertBlockState(BlockPos arg0, Predicate<BlockState> arg1, Supplier<String> arg2)",
			"fabric": "checkBlockState(BlockPos pos, Predicate<BlockState> predicate, Supplier<String> errorMessageSupplier)"
		},
		{
			"forge": "assertRedstoneSignal(BlockPos arg0, Direction arg1, IntPredicate arg2, Supplier<String> arg3)",
			"fabric": "expectRedstonePower(BlockPos pos, Direction direction, IntPredicate powerPredicate, Supplier<String> errorMessage)"
		},
		{
			"forge": "assertEntityPresent(EntityType<?> arg0)",
			"fabric": "expectEntity(EntityType<?> type)"
		},
		{
			"forge": "assertEntityPresent(EntityType<?> arg0, int arg1, int arg2, int arg3)",
			"fabric": "expectEntityAt(EntityType<?> type, int x, int y, int z)"
		},
		{
			"forge": "assertEntityPresent(EntityType<?> arg0, BlockPos arg1)",
			"fabric": "expectEntityAt(EntityType<?> type, BlockPos pos)"
		},
		{
			"forge": "assertEntityPresent(EntityType<?> arg0, Vec3 arg1, Vec3 arg2)",
			"fabric": "expectEntityInside(EntityType<?> type, Vec3d pos1, Vec3d pos2)"
		},
		{
			"forge": "assertEntitiesPresent(EntityType<?> arg0, BlockPos arg1, int arg2, double arg3)",
			"fabric": "expectEntitiesAround(EntityType<?> type, BlockPos pos, int amount, double radius)"
		},
		{
			"forge": "assertEntityPresent(EntityType<?> arg0, BlockPos arg1, double arg2)",
			"fabric": "expectEntityAround(EntityType<?> type, BlockPos pos, double radius)"
		},
		{
			"forge": "getEntities(EntityType<T> arg0, BlockPos arg1, double arg2)",
			"fabric": "getEntitiesAround(EntityType<T> type, BlockPos pos, double radius)"
		},
		{
			"forge": "assertEntityInstancePresent(Entity arg0, int arg1, int arg2, int arg3)",
			"fabric": "expectEntityAt(Entity entity, int x, int y, int z)"
		},
		{
			"forge": "assertEntityInstancePresent(Entity arg0, BlockPos arg1)",
			"fabric": "expectEntityAt(Entity entity, BlockPos pos)"
		},
		{
			"forge": "assertItemEntityCountIs(Item arg0, BlockPos arg1, double arg2, int arg3)",
			"fabric": "expectItemsAt(Item item, BlockPos pos, double radius, int amount)"
		},
		{
			"forge": "assertItemEntityPresent(Item arg0, BlockPos arg1, double arg2)",
			"fabric": "expectItemAt(Item item, BlockPos pos, double radius)"
		},
		{
			"forge": "assertItemEntityNotPresent(Item arg0, BlockPos arg1, double arg2)",
			"fabric": "dontExpectItemAt(Item item, BlockPos pos, double radius)"
		},
		{
			"forge": "assertEntityNotPresent(EntityType<?> arg0)",
			"fabric": "dontExpectEntity(EntityType<?> type)"
		},
		{
			"forge": "assertEntityNotPresent(EntityType<?> arg0, int arg1, int arg2, int arg3)",
			"fabric": "dontExpectEntityAt(EntityType<?> type, int x, int y, int z)"
		},
		{
			"forge": "assertEntityNotPresent(EntityType<?> arg0, BlockPos arg1)",
			"fabric": "dontExpectEntityAt(EntityType<?> type, BlockPos pos)"
		},
		{
			"forge": "assertEntityTouching(EntityType<?> arg0, double arg1, double arg2, double arg3)",
			"fabric": "expectEntityToTouch(EntityType<?> type, double x, double y, double z)"
		},
		{
			"forge": "assertEntityNotTouching(EntityType<?> arg0, double arg1, double arg2, double arg3)",
			"fabric": "dontExpectEntityToTouch(EntityType<?> type, double x, double y, double z)"
		},
		{
			"forge": "assertEntityData(BlockPos arg0, EntityType<E> arg1, Function<? super E, T> arg2, T arg3)",
			"fabric": "expectEntityWithData(BlockPos pos, EntityType<E> type, Function<? super E, T> entityDataGetter, T data)"
		},
		{
			"forge": "assertEntityIsHolding(BlockPos arg0, EntityType<E> arg1, Item arg2)",
			"fabric": "expectEntityHoldingItem(BlockPos pos, EntityType<E> entityType, Item item)"
		},
		{
			"forge": "assertEntityInventoryContains(BlockPos arg0, EntityType<E> arg1, Item arg2)",
			"fabric": "expectEntityWithItem(BlockPos pos, EntityType<E> entityType, Item item)"
		},
		{
			"forge": "assertContainerEmpty(BlockPos arg0)",
			"fabric": "expectEmptyContainer(BlockPos pos)"
		},
		{
			"forge": "assertContainerContains(BlockPos arg0, Item arg1)",
			"fabric": "expectContainerWith(BlockPos pos, Item item)"
		},
		{
			"forge": "assertSameBlockStates(BoundingBox arg0, BlockPos arg1)",
			"fabric": "expectSameStates(BlockBox checkedBlockBox, BlockPos correctStatePos)"
		},
		{
			"forge": "assertSameBlockState(BlockPos arg0, BlockPos arg1)",
			"fabric": "expectSameStates(BlockPos checkedPos, BlockPos correctStatePos)"
		},
		{
			"forge": "assertAtTickTimeContainerContains(long arg0, BlockPos arg1, Item arg2)",
			"fabric": "expectContainerWith(long delay, BlockPos pos, Item item)"
		},
		{
			"forge": "assertAtTickTimeContainerEmpty(long arg0, BlockPos arg1)",
			"fabric": "expectEmptyContainer(long delay, BlockPos pos)"
		},
		{
			"forge": "succeedWhenEntityData(BlockPos arg0, EntityType<E> arg1, Function<E, T> arg2, T arg3)",
			"fabric": "expectEntityWithDataEnd(BlockPos pos, EntityType<E> type, Function<E, T> entityDataGetter, T data)"
		},
		{
			"forge": "assertEntityProperty(E arg0, Predicate<E> arg1, String arg2)",
			"fabric": "testEntity(E entity, Predicate<E> predicate, String testName)"
		},
		{
			"forge": "assertEntityProperty(E arg0, Function<E, T> arg1, String arg2, T arg3)",
			"fabric": "testEntityProperty(E entity, Function<E, T> propertyGetter, String propertyName, T expectedValue)"
		},
		{
			"forge": "succeedWhenEntityPresent(EntityType<?> arg0, int arg1, int arg2, int arg3)",
			"fabric": "expectEntityAtEnd(EntityType<?> type, int x, int y, int z)"
		},
		{
			"forge": "succeedWhenEntityPresent(EntityType<?> arg0, BlockPos arg1)",
			"fabric": "expectEntityAtEnd(EntityType<?> type, BlockPos pos)"
		},
		{
			"forge": "succeedWhenEntityNotPresent(EntityType<?> arg0, int arg1, int arg2, int arg3)",
			"fabric": "dontExpectEntityAtEnd(EntityType<?> type, int x, int y, int z)"
		},
		{
			"forge": "succeedWhenEntityNotPresent(EntityType<?> arg0, BlockPos arg1)",
			"fabric": "dontExpectEntityAtEnd(EntityType<?> type, BlockPos pos)"
		},
		{
			"forge": "succeed()",
			"fabric": "complete()"
		},
		{
			"forge": "ensureSingleFinalCheck()",
			"fabric": "markFinalCause()"
		},
		{
			"forge": "succeedIf(Runnable arg0)",
			"fabric": "addFinalTask(Runnable runnable)"
		},
		{
			"forge": "succeedWhen(Runnable arg0)",
			"fabric": "addInstantFinalTask(Runnable runnable)"
		},
		{
			"forge": "succeedOnTickWhen(int arg0, Runnable arg1)",
			"fabric": "addFinalTaskWithDuration(int duration, Runnable runnable)"
		},
		{
			"forge": "runAtTickTime(long arg0, Runnable arg1)",
			"fabric": "runAtTick(long tick, Runnable runnable)"
		},
		{
			"forge": "runAfterDelay(long arg0, Runnable arg1)",
			"fabric": "waitAndRun(long ticks, Runnable runnable)"
		},
		{
			"forge": "randomTick(BlockPos arg0)",
			"fabric": "forceRandomTick(BlockPos pos)"
		},
		{
			"forge": "getHeight(Heightmap$Types arg0, int arg1, int arg2)",
			"fabric": "getRelativeTopY(Heightmap$Type heightmap, int x, int z)"
		},
		{
			"forge": "fail(String arg0, BlockPos arg1)",
			"fabric": "throwPositionedException(String message, BlockPos pos)"
		},
		{
			"forge": "fail(String arg0, Entity arg1)",
			"fabric": "throwPositionedException(String message, Entity entity)"
		},
		{
			"forge": "fail(String arg0)",
			"fabric": "throwGameTestException(String message)"
		},
		{
			"forge": "failIf(Runnable arg0)",
			"fabric": "addTask(Runnable task)"
		},
		{
			"forge": "failIfEver(Runnable arg0)",
			"fabric": "runAtEveryTick(Runnable task)"
		},
		{
			"forge": "startSequence()",
			"fabric": "createTimedTaskRunner()"
		},
		{
			"forge": "absolutePos(BlockPos arg0)",
			"fabric": "getAbsolutePos(BlockPos pos)"
		},
		{
			"forge": "relativePos(BlockPos arg0)",
			"fabric": "getRelativePos(BlockPos pos)"
		},
		{
			"forge": "absoluteVec(Vec3 arg0)",
			"fabric": "getAbsolute(Vec3d pos)"
		},
		{
			"forge": "relativeVec(Vec3 arg0)",
			"fabric": "getRelative(Vec3d pos)"
		},
		{
			"forge": "assertTrue(boolean arg0, String arg1)",
			"fabric": "assertTrue(boolean condition, String message)"
		},
		{
			"forge": "assertFalse(boolean arg0, String arg1)",
			"fabric": "assertFalse(boolean condition, String message)"
		},
		{
			"forge": "getTick()",
			"fabric": "getTick()"
		},
		{
			"forge": "getBounds()",
			"fabric": "getTestBox()"
		},
		{
			"forge": "getRelativeBounds()",
			"fabric": "getRelativeTestBox()"
		},
		{
			"forge": "forEveryBlockInStructure(Consumer<BlockPos> arg0)",
			"fabric": "forEachRelativePos(Consumer<BlockPos> posConsumer)"
		},
		{
			"forge": "onEachTick(Runnable arg0)",
			"fabric": "forEachRemainingTick(Runnable runnable)"
		},
		{
			"forge": "placeAt(Player arg0, ItemStack arg1, BlockPos arg2, Direction arg3)",
			"fabric": "useStackOnBlock(PlayerEntity player, ItemStack stack, BlockPos pos, Direction direction)"
		}
	]
}