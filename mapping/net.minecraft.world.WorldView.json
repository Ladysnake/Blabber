{
	"title": "net.minecraft.world.level.LevelReader",
	"items": [
		{
			"forge": "net.minecraft.world.level.LevelReader",
			"fabric": "net.minecraft.world.WorldView"
		},
		{
			"forge": "getChunk(int arg0, int arg1, ChunkStatus arg2, boolean arg3)",
			"fabric": "getChunk(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create)"
		},
		{
			"forge": "getChunk(int arg0, int arg1, ChunkStatus arg2, boolean arg3)",
			"fabric": "getChunk(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create)"
		},
		{
			"forge": "hasChunk(int arg0, int arg1)",
			"fabric": "isChunkLoaded(int chunkX, int chunkZ)"
		},
		{
			"forge": "getHeight(Heightmap$Types arg0, int arg1, int arg2)",
			"fabric": "getTopY(Heightmap$Type heightmap, int x, int z)"
		},
		{
			"forge": "getSkyDarken()",
			"fabric": "getAmbientDarkness()"
		},
		{
			"forge": "getBiomeManager()",
			"fabric": "getBiomeAccess()"
		},
		{
			"forge": "getBiome(BlockPos arg0)",
			"fabric": "getBiome(BlockPos pos)"
		},
		{
			"forge": "getBlockStatesIfLoaded(AABB arg0)",
			"fabric": "getStatesInBoxIfLoaded(Box box)"
		},
		{
			"forge": "getBlockTint(BlockPos arg0, ColorResolver arg1)",
			"fabric": "getColor(BlockPos arg0, ColorResolver arg1)"
		},
		{
			"forge": "getNoiseBiome(int arg0, int arg1, int arg2)",
			"fabric": "getBiomeForNoiseGen(int arg0, int arg1, int arg2)"
		},
		{
			"forge": "getUncachedNoiseBiome(int arg0, int arg1, int arg2)",
			"fabric": "getGeneratorStoredBiome(int biomeX, int biomeY, int biomeZ)"
		},
		{
			"forge": "isClientSide()",
			"fabric": "isClient()"
		},
		{
			"forge": "getSeaLevel()",
			"fabric": "getSeaLevel()"
		},
		{
			"forge": "dimensionType()",
			"fabric": "getDimension()"
		},
		{
			"forge": "getMinBuildHeight()",
			"fabric": "getBottomY()"
		},
		{
			"forge": "getHeight()",
			"fabric": "getHeight()"
		},
		{
			"forge": "getHeightmapPos(Heightmap$Types arg0, BlockPos arg1)",
			"fabric": "getTopPosition(Heightmap$Type heightmap, BlockPos pos)"
		},
		{
			"forge": "isEmptyBlock(BlockPos arg0)",
			"fabric": "isAir(BlockPos pos)"
		},
		{
			"forge": "canSeeSkyFromBelowWater(BlockPos arg0)",
			"fabric": "isSkyVisibleAllowingSea(BlockPos pos)"
		},
		{
			"forge": "getPathfindingCostFromLightLevels(BlockPos arg0)",
			"fabric": "getPhototaxisFavor(BlockPos pos)"
		},
		{
			"forge": "getLightLevelDependentMagicValue(BlockPos arg0)",
			"fabric": "getBrightness(BlockPos pos)"
		},
		{
			"forge": "getChunk(BlockPos arg0)",
			"fabric": "getChunk(BlockPos pos)"
		},
		{
			"forge": "getChunk(int arg0, int arg1)",
			"fabric": "getChunk(int chunkX, int chunkZ)"
		},
		{
			"forge": "getChunk(int arg0, int arg1, ChunkStatus arg2)",
			"fabric": "getChunk(int chunkX, int chunkZ, ChunkStatus status)"
		},
		{
			"forge": "getChunkForCollisions(int arg0, int arg1)",
			"fabric": "getChunkAsView(int arg0, int arg1)"
		},
		{
			"forge": "isWaterAt(BlockPos arg0)",
			"fabric": "isWater(BlockPos pos)"
		},
		{
			"forge": "containsAnyLiquid(AABB arg0)",
			"fabric": "containsFluid(Box box)"
		},
		{
			"forge": "getMaxLocalRawBrightness(BlockPos arg0)",
			"fabric": "getLightLevel(BlockPos pos)"
		},
		{
			"forge": "getMaxLocalRawBrightness(BlockPos arg0, int arg1)",
			"fabric": "getLightLevel(BlockPos pos, int ambientDarkness)"
		},
		{
			"forge": "hasChunkAt(int arg0, int arg1)",
			"fabric": "isPosLoaded(int x, int z)"
		},
		{
			"forge": "hasChunkAt(BlockPos arg0)",
			"fabric": "isChunkLoaded(BlockPos pos)"
		},
		{
			"forge": "hasChunksAt(BlockPos arg0, BlockPos arg1)",
			"fabric": "isRegionLoaded(BlockPos min, BlockPos max)"
		},
		{
			"forge": "hasChunksAt(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)",
			"fabric": "isRegionLoaded(int minX, int minY, int minZ, int maxX, int maxY, int maxZ)"
		},
		{
			"forge": "hasChunksAt(int arg0, int arg1, int arg2, int arg3)",
			"fabric": "isRegionLoaded(int minX, int minZ, int maxX, int maxZ)"
		},
		{
			"forge": "registryAccess()",
			"fabric": "getRegistryManager()"
		},
		{
			"forge": "enabledFeatures()",
			"fabric": "getEnabledFeatures()"
		},
		{
			"forge": "holderLookup(ResourceKey<? extends Registry<? extends T>> arg0)",
			"fabric": "createCommandRegistryWrapper(RegistryKey<? extends Registry<? extends T>> registryRef)"
		}
	]
}