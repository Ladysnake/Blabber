{
	"title": "net.minecraft.world.entity.LivingEntity",
	"items": [
		{
			"forge": "net.minecraft.world.entity.LivingEntity",
			"fabric": "net.minecraft.entity.LivingEntity"
		},
		{
			"forge": "LOGGER",
			"fabric": "LOGGER"
		},
		{
			"forge": "LOGGER",
			"fabric": "LOGGER"
		},
		{
			"forge": "SPEED_MODIFIER_SPRINTING_UUID",
			"fabric": "SPRINTING_SPEED_BOOST_ID"
		},
		{
			"forge": "SPEED_MODIFIER_SOUL_SPEED_UUID",
			"fabric": "SOUL_SPEED_BOOST_ID"
		},
		{
			"forge": "SPEED_MODIFIER_POWDER_SNOW_UUID",
			"fabric": "POWDER_SNOW_SLOW_ID"
		},
		{
			"forge": "SPEED_MODIFIER_SPRINTING",
			"fabric": "SPRINTING_SPEED_BOOST"
		},
		{
			"forge": "HAND_SLOTS",
			"fabric": "field_30069"
		},
		{
			"forge": "ARMOR_SLOTS",
			"fabric": "field_30070"
		},
		{
			"forge": "EQUIPMENT_SLOT_OFFSET",
			"fabric": "EQUIPMENT_SLOT_ID"
		},
		{
			"forge": "ARMOR_SLOT_OFFSET",
			"fabric": "field_30072"
		},
		{
			"forge": "SWING_DURATION",
			"fabric": "GLOWING_FLAG"
		},
		{
			"forge": "PLAYER_HURT_EXPERIENCE_TIME",
			"fabric": "field_30074"
		},
		{
			"forge": "DAMAGE_SOURCE_TIMEOUT",
			"fabric": "field_30078"
		},
		{
			"forge": "MIN_MOVEMENT_DISTANCE",
			"fabric": "field_30075"
		},
		{
			"forge": "DEFAULT_BASE_GRAVITY",
			"fabric": "GRAVITY"
		},
		{
			"forge": "DEATH_DURATION",
			"fabric": "DEATH_TICKS"
		},
		{
			"forge": "WAIT_TICKS_BEFORE_ITEM_USE_EFFECTS",
			"fabric": "FALL_FLYING_FLAG"
		},
		{
			"forge": "TICKS_PER_ELYTRA_FREE_FALL_EVENT",
			"fabric": "field_30080"
		},
		{
			"forge": "FREE_FALL_EVENTS_PER_ELYTRA_BREAK",
			"fabric": "field_30081"
		},
		{
			"forge": "USE_ITEM_INTERVAL",
			"fabric": "field_30063"
		},
		{
			"forge": "BASE_JUMP_POWER",
			"fabric": "field_44874"
		},
		{
			"forge": "MAX_LINE_OF_SIGHT_TEST_RANGE",
			"fabric": "MAX_ENTITY_VIEWING_DISTANCE"
		},
		{
			"forge": "LIVING_ENTITY_FLAG_IS_USING",
			"fabric": "USING_ITEM_FLAG"
		},
		{
			"forge": "LIVING_ENTITY_FLAG_OFF_HAND",
			"fabric": "OFF_HAND_ACTIVE_FLAG"
		},
		{
			"forge": "LIVING_ENTITY_FLAG_SPIN_ATTACK",
			"fabric": "USING_RIPTIDE_FLAG"
		},
		{
			"forge": "DATA_LIVING_ENTITY_FLAGS",
			"fabric": "LIVING_FLAGS"
		},
		{
			"forge": "DATA_HEALTH_ID",
			"fabric": "HEALTH"
		},
		{
			"forge": "DATA_EFFECT_COLOR_ID",
			"fabric": "POTION_SWIRLS_COLOR"
		},
		{
			"forge": "DATA_EFFECT_AMBIENCE_ID",
			"fabric": "POTION_SWIRLS_AMBIENT"
		},
		{
			"forge": "DATA_ARROW_COUNT_ID",
			"fabric": "STUCK_ARROW_COUNT"
		},
		{
			"forge": "DATA_STINGER_COUNT_ID",
			"fabric": "STINGER_COUNT"
		},
		{
			"forge": "SLEEPING_POS_ID",
			"fabric": "SLEEPING_POSITION"
		},
		{
			"forge": "DEFAULT_EYE_HEIGHT",
			"fabric": "field_30067"
		},
		{
			"forge": "SLEEPING_DIMENSIONS",
			"fabric": "SLEEPING_DIMENSIONS"
		},
		{
			"forge": "EXTRA_RENDER_CULLING_SIZE_WITH_BIG_HAT",
			"fabric": "BABY_SCALE_FACTOR"
		},
		{
			"forge": "MAX_HEAD_ROTATION_RELATIVE_TO_BODY",
			"fabric": "field_42636"
		},
		{
			"forge": "attributes",
			"fabric": "attributes"
		},
		{
			"forge": "combatTracker",
			"fabric": "damageTracker"
		},
		{
			"forge": "activeEffects",
			"fabric": "activeStatusEffects"
		},
		{
			"forge": "lastHandItemStacks",
			"fabric": "syncedHandStacks"
		},
		{
			"forge": "lastArmorItemStacks",
			"fabric": "syncedArmorStacks"
		},
		{
			"forge": "swinging",
			"fabric": "handSwinging"
		},
		{
			"forge": "discardFriction",
			"fabric": "noDrag"
		},
		{
			"forge": "swingingArm",
			"fabric": "preferredHand"
		},
		{
			"forge": "swingTime",
			"fabric": "handSwingTicks"
		},
		{
			"forge": "removeArrowTime",
			"fabric": "stuckArrowTimer"
		},
		{
			"forge": "removeStingerTime",
			"fabric": "stuckStingerTimer"
		},
		{
			"forge": "hurtTime",
			"fabric": "hurtTime"
		},
		{
			"forge": "hurtDuration",
			"fabric": "maxHurtTime"
		},
		{
			"forge": "deathTime",
			"fabric": "deathTime"
		},
		{
			"forge": "oAttackAnim",
			"fabric": "lastHandSwingProgress"
		},
		{
			"forge": "attackAnim",
			"fabric": "handSwingProgress"
		},
		{
			"forge": "attackStrengthTicker",
			"fabric": "lastAttackedTicks"
		},
		{
			"forge": "walkAnimation",
			"fabric": "limbAnimator"
		},
		{
			"forge": "invulnerableDuration",
			"fabric": "defaultMaxHealth"
		},
		{
			"forge": "timeOffs",
			"fabric": "randomLargeSeed"
		},
		{
			"forge": "rotA",
			"fabric": "randomSmallSeed"
		},
		{
			"forge": "yBodyRot",
			"fabric": "bodyYaw"
		},
		{
			"forge": "yBodyRotO",
			"fabric": "prevBodyYaw"
		},
		{
			"forge": "yHeadRot",
			"fabric": "headYaw"
		},
		{
			"forge": "yHeadRotO",
			"fabric": "prevHeadYaw"
		},
		{
			"forge": "lastHurtByPlayer",
			"fabric": "attackingPlayer"
		},
		{
			"forge": "lastHurtByPlayerTime",
			"fabric": "playerHitTimer"
		},
		{
			"forge": "dead",
			"fabric": "dead"
		},
		{
			"forge": "noActionTime",
			"fabric": "despawnCounter"
		},
		{
			"forge": "oRun",
			"fabric": "prevStepBobbingAmount"
		},
		{
			"forge": "run",
			"fabric": "stepBobbingAmount"
		},
		{
			"forge": "animStep",
			"fabric": "lookDirection"
		},
		{
			"forge": "animStepO",
			"fabric": "prevLookDirection"
		},
		{
			"forge": "rotOffs",
			"fabric": "field_6215"
		},
		{
			"forge": "deathScore",
			"fabric": "scoreAmount"
		},
		{
			"forge": "lastHurt",
			"fabric": "lastDamageTaken"
		},
		{
			"forge": "jumping",
			"fabric": "jumping"
		},
		{
			"forge": "xxa",
			"fabric": "sidewaysSpeed"
		},
		{
			"forge": "yya",
			"fabric": "upwardSpeed"
		},
		{
			"forge": "zza",
			"fabric": "forwardSpeed"
		},
		{
			"forge": "lerpSteps",
			"fabric": "bodyTrackingIncrements"
		},
		{
			"forge": "lerpX",
			"fabric": "serverX"
		},
		{
			"forge": "lerpY",
			"fabric": "serverY"
		},
		{
			"forge": "lerpZ",
			"fabric": "serverZ"
		},
		{
			"forge": "lerpYRot",
			"fabric": "serverYaw"
		},
		{
			"forge": "lerpXRot",
			"fabric": "serverPitch"
		},
		{
			"forge": "lyHeadRot",
			"fabric": "serverHeadYaw"
		},
		{
			"forge": "lerpHeadSteps",
			"fabric": "headTrackingIncrements"
		},
		{
			"forge": "effectsDirty",
			"fabric": "effectsChanged"
		},
		{
			"forge": "lastHurtByMob",
			"fabric": "attacker"
		},
		{
			"forge": "lastHurtByMobTimestamp",
			"fabric": "lastAttackedTime"
		},
		{
			"forge": "lastHurtMob",
			"fabric": "attacking"
		},
		{
			"forge": "lastHurtMobTimestamp",
			"fabric": "lastAttackTime"
		},
		{
			"forge": "speed",
			"fabric": "movementSpeed"
		},
		{
			"forge": "noJumpDelay",
			"fabric": "jumpingCooldown"
		},
		{
			"forge": "absorptionAmount",
			"fabric": "absorptionAmount"
		},
		{
			"forge": "useItem",
			"fabric": "activeItemStack"
		},
		{
			"forge": "useItemRemaining",
			"fabric": "itemUseTimeLeft"
		},
		{
			"forge": "fallFlyTicks",
			"fabric": "roll"
		},
		{
			"forge": "lastPos",
			"fabric": "lastBlockPos"
		},
		{
			"forge": "lastClimbablePos",
			"fabric": "climbingPos"
		},
		{
			"forge": "lastDamageSource",
			"fabric": "lastDamageSource"
		},
		{
			"forge": "lastDamageStamp",
			"fabric": "lastDamageTime"
		},
		{
			"forge": "autoSpinAttackTicks",
			"fabric": "riptideTicks"
		},
		{
			"forge": "swimAmount",
			"fabric": "leaningPitch"
		},
		{
			"forge": "swimAmountO",
			"fabric": "lastLeaningPitch"
		},
		{
			"forge": "brain",
			"fabric": "brain"
		},
		{
			"forge": "skipDropExperience",
			"fabric": "experienceDroppingDisabled"
		},
		{
			"forge": "getBrain()",
			"fabric": "getBrain()"
		},
		{
			"forge": "getBrain()",
			"fabric": "getBrain()"
		},
		{
			"forge": "brainProvider()",
			"fabric": "createBrainProfile()"
		},
		{
			"forge": "makeBrain(com.mojang.serialization.Dynamic<?> arg0)",
			"fabric": "deserializeBrain(com.mojang.serialization.Dynamic<?> dynamic)"
		},
		{
			"forge": "kill()",
			"fabric": "kill()"
		},
		{
			"forge": "canAttackType(EntityType<?> arg0)",
			"fabric": "canTarget(EntityType<?> type)"
		},
		{
			"forge": "defineSynchedData()",
			"fabric": "initDataTracker()"
		},
		{
			"forge": "createLivingAttributes()",
			"fabric": "createLivingAttributes()"
		},
		{
			"forge": "checkFallDamage(double arg0, boolean arg1, BlockState arg2, BlockPos arg3)",
			"fabric": "fall(double arg0, boolean arg1, BlockState arg2, BlockPos arg3)"
		},
		{
			"forge": "canBreatheUnderwater()",
			"fabric": "canBreatheInWater()"
		},
		{
			"forge": "getSwimAmount(float arg0)",
			"fabric": "getLeaningPitch(float tickDelta)"
		},
		{
			"forge": "baseTick()",
			"fabric": "baseTick()"
		},
		{
			"forge": "canSpawnSoulSpeedParticle()",
			"fabric": "shouldDisplaySoulSpeedEffects()"
		},
		{
			"forge": "spawnSoulSpeedParticle()",
			"fabric": "displaySoulSpeedEffects()"
		},
		{
			"forge": "onSoulSpeedBlock()",
			"fabric": "isOnSoulSpeedBlock()"
		},
		{
			"forge": "getBlockSpeedFactor()",
			"fabric": "getVelocityMultiplier()"
		},
		{
			"forge": "shouldRemoveSoulSpeed(BlockState arg0)",
			"fabric": "shouldRemoveSoulSpeedBoost(BlockState landingState)"
		},
		{
			"forge": "removeSoulSpeed()",
			"fabric": "removeSoulSpeedBoost()"
		},
		{
			"forge": "tryAddSoulSpeed()",
			"fabric": "addSoulSpeedBoostIfNeeded()"
		},
		{
			"forge": "removeFrost()",
			"fabric": "removePowderSnowSlow()"
		},
		{
			"forge": "tryAddFrost()",
			"fabric": "addPowderSnowSlowIfNeeded()"
		},
		{
			"forge": "onChangedBlock(BlockPos arg0)",
			"fabric": "applyMovementEffects(BlockPos pos)"
		},
		{
			"forge": "isBaby()",
			"fabric": "isBaby()"
		},
		{
			"forge": "getScale()",
			"fabric": "getScaleFactor()"
		},
		{
			"forge": "isAffectedByFluids()",
			"fabric": "shouldSwimInFluids()"
		},
		{
			"forge": "tickDeath()",
			"fabric": "updatePostDeath()"
		},
		{
			"forge": "shouldDropExperience()",
			"fabric": "shouldDropXp()"
		},
		{
			"forge": "shouldDropLoot()",
			"fabric": "shouldDropLoot()"
		},
		{
			"forge": "decreaseAirSupply(int arg0)",
			"fabric": "getNextAirUnderwater(int air)"
		},
		{
			"forge": "increaseAirSupply(int arg0)",
			"fabric": "getNextAirOnLand(int air)"
		},
		{
			"forge": "getExperienceReward()",
			"fabric": "getXpToDrop()"
		},
		{
			"forge": "isAlwaysExperienceDropper()",
			"fabric": "shouldAlwaysDropXp()"
		},
		{
			"forge": "getRandom()",
			"fabric": "getRandom()"
		},
		{
			"forge": "getLastHurtByMob()",
			"fabric": "getAttacker()"
		},
		{
			"forge": "getLastAttacker()",
			"fabric": "getLastAttacker()"
		},
		{
			"forge": "getLastHurtByMobTimestamp()",
			"fabric": "getLastAttackedTime()"
		},
		{
			"forge": "setLastHurtByPlayer(Player arg0)",
			"fabric": "setAttacking(PlayerEntity attacking)"
		},
		{
			"forge": "setLastHurtByMob(LivingEntity arg0)",
			"fabric": "setAttacker(LivingEntity attacker)"
		},
		{
			"forge": "getLastHurtMob()",
			"fabric": "getAttacking()"
		},
		{
			"forge": "getLastHurtMobTimestamp()",
			"fabric": "getLastAttackTime()"
		},
		{
			"forge": "setLastHurtMob(Entity arg0)",
			"fabric": "onAttacking(Entity target)"
		},
		{
			"forge": "getNoActionTime()",
			"fabric": "getDespawnCounter()"
		},
		{
			"forge": "setNoActionTime(int arg0)",
			"fabric": "setDespawnCounter(int despawnCounter)"
		},
		{
			"forge": "shouldDiscardFriction()",
			"fabric": "hasNoDrag()"
		},
		{
			"forge": "setDiscardFriction(boolean arg0)",
			"fabric": "setNoDrag(boolean noDrag)"
		},
		{
			"forge": "doesEmitEquipEvent(EquipmentSlot arg0)",
			"fabric": "isArmorSlot(EquipmentSlot slot)"
		},
		{
			"forge": "onEquipItem(EquipmentSlot arg0, ItemStack arg1, ItemStack arg2)",
			"fabric": "onEquipStack(EquipmentSlot slot, ItemStack oldStack, ItemStack newStack)"
		},
		{
			"forge": "remove(Entity$RemovalReason arg0)",
			"fabric": "remove(Entity$RemovalReason arg0)"
		},
		{
			"forge": "addAdditionalSaveData(CompoundTag arg0)",
			"fabric": "writeCustomDataToNbt(NbtCompound arg0)"
		},
		{
			"forge": "readAdditionalSaveData(CompoundTag arg0)",
			"fabric": "readCustomDataFromNbt(NbtCompound arg0)"
		},
		{
			"forge": "tickEffects()",
			"fabric": "tickStatusEffects()"
		},
		{
			"forge": "updateInvisibilityStatus()",
			"fabric": "updatePotionVisibility()"
		},
		{
			"forge": "updateGlowingStatus()",
			"fabric": "updateGlowing()"
		},
		{
			"forge": "getVisibilityPercent(Entity arg0)",
			"fabric": "getAttackDistanceScalingFactor(Entity entity)"
		},
		{
			"forge": "canAttack(LivingEntity arg0)",
			"fabric": "canTarget(LivingEntity target)"
		},
		{
			"forge": "canAttack(LivingEntity arg0, TargetingConditions arg1)",
			"fabric": "isTarget(LivingEntity entity, TargetPredicate predicate)"
		},
		{
			"forge": "canBeSeenAsEnemy()",
			"fabric": "canTakeDamage()"
		},
		{
			"forge": "canBeSeenByAnyone()",
			"fabric": "isPartOfGame()"
		},
		{
			"forge": "areAllEffectsAmbient(Collection<MobEffectInstance> arg0)",
			"fabric": "containsOnlyAmbientEffects(Collection<StatusEffectInstance> effects)"
		},
		{
			"forge": "removeEffectParticles()",
			"fabric": "clearPotionSwirls()"
		},
		{
			"forge": "removeAllEffects()",
			"fabric": "clearStatusEffects()"
		},
		{
			"forge": "getActiveEffects()",
			"fabric": "getStatusEffects()"
		},
		{
			"forge": "getActiveEffectsMap()",
			"fabric": "getActiveStatusEffects()"
		},
		{
			"forge": "hasEffect(MobEffect arg0)",
			"fabric": "hasStatusEffect(StatusEffect effect)"
		},
		{
			"forge": "getEffect(MobEffect arg0)",
			"fabric": "getStatusEffect(StatusEffect effect)"
		},
		{
			"forge": "addEffect(MobEffectInstance arg0)",
			"fabric": "addStatusEffect(StatusEffectInstance effect)"
		},
		{
			"forge": "addEffect(MobEffectInstance arg0, Entity arg1)",
			"fabric": "addStatusEffect(StatusEffectInstance effect, Entity source)"
		},
		{
			"forge": "canBeAffected(MobEffectInstance arg0)",
			"fabric": "canHaveStatusEffect(StatusEffectInstance effect)"
		},
		{
			"forge": "forceAddEffect(MobEffectInstance arg0, Entity arg1)",
			"fabric": "setStatusEffect(StatusEffectInstance effect, Entity source)"
		},
		{
			"forge": "isInvertedHealAndHarm()",
			"fabric": "isUndead()"
		},
		{
			"forge": "removeEffectNoUpdate(MobEffect arg0)",
			"fabric": "removeStatusEffectInternal(StatusEffect type)"
		},
		{
			"forge": "removeEffect(MobEffect arg0)",
			"fabric": "removeStatusEffect(StatusEffect type)"
		},
		{
			"forge": "onEffectAdded(MobEffectInstance arg0, Entity arg1)",
			"fabric": "onStatusEffectApplied(StatusEffectInstance effect, Entity source)"
		},
		{
			"forge": "sendEffectToPassengers(MobEffectInstance arg0)",
			"fabric": "sendEffectToControllingPlayer(StatusEffectInstance effect)"
		},
		{
			"forge": "onEffectUpdated(MobEffectInstance arg0, boolean arg1, Entity arg2)",
			"fabric": "onStatusEffectUpgraded(StatusEffectInstance effect, boolean reapplyEffect, Entity source)"
		},
		{
			"forge": "onEffectRemoved(MobEffectInstance arg0)",
			"fabric": "onStatusEffectRemoved(StatusEffectInstance effect)"
		},
		{
			"forge": "heal(float arg0)",
			"fabric": "heal(float amount)"
		},
		{
			"forge": "getHealth()",
			"fabric": "getHealth()"
		},
		{
			"forge": "setHealth(float arg0)",
			"fabric": "setHealth(float health)"
		},
		{
			"forge": "isDeadOrDying()",
			"fabric": "isDead()"
		},
		{
			"forge": "hurt(DamageSource arg0, float arg1)",
			"fabric": "damage(DamageSource arg0, float arg1)"
		},
		{
			"forge": "blockUsingShield(LivingEntity arg0)",
			"fabric": "takeShieldHit(LivingEntity attacker)"
		},
		{
			"forge": "blockedByShield(LivingEntity arg0)",
			"fabric": "knockback(LivingEntity target)"
		},
		{
			"forge": "checkTotemDeathProtection(DamageSource arg0)",
			"fabric": "tryUseTotem(DamageSource source)"
		},
		{
			"forge": "getLastDamageSource()",
			"fabric": "getRecentDamageSource()"
		},
		{
			"forge": "playHurtSound(DamageSource arg0)",
			"fabric": "playHurtSound(DamageSource source)"
		},
		{
			"forge": "isDamageSourceBlocked(DamageSource arg0)",
			"fabric": "blockedByShield(DamageSource source)"
		},
		{
			"forge": "breakItem(ItemStack arg0)",
			"fabric": "playEquipmentBreakEffects(ItemStack stack)"
		},
		{
			"forge": "die(DamageSource arg0)",
			"fabric": "onDeath(DamageSource damageSource)"
		},
		{
			"forge": "createWitherRose(LivingEntity arg0)",
			"fabric": "onKilledBy(LivingEntity adversary)"
		},
		{
			"forge": "dropAllDeathLoot(DamageSource arg0)",
			"fabric": "drop(DamageSource source)"
		},
		{
			"forge": "dropEquipment()",
			"fabric": "dropInventory()"
		},
		{
			"forge": "dropExperience()",
			"fabric": "dropXp()"
		},
		{
			"forge": "dropCustomDeathLoot(DamageSource arg0, int arg1, boolean arg2)",
			"fabric": "dropEquipment(DamageSource source, int lootingMultiplier, boolean allowDrops)"
		},
		{
			"forge": "getLootTable()",
			"fabric": "getLootTable()"
		},
		{
			"forge": "getLootTableSeed()",
			"fabric": "getLootTableSeed()"
		},
		{
			"forge": "dropFromLootTable(DamageSource arg0, boolean arg1)",
			"fabric": "dropLoot(DamageSource damageSource, boolean causedByPlayer)"
		},
		{
			"forge": "knockback(double arg0, double arg1, double arg2)",
			"fabric": "takeKnockback(double strength, double x, double z)"
		},
		{
			"forge": "indicateDamage(double arg0, double arg1)",
			"fabric": "tiltScreen(double deltaX, double deltaZ)"
		},
		{
			"forge": "getHurtSound(DamageSource arg0)",
			"fabric": "getHurtSound(DamageSource source)"
		},
		{
			"forge": "getDeathSound()",
			"fabric": "getDeathSound()"
		},
		{
			"forge": "getFallDamageSound(int arg0)",
			"fabric": "getFallSound(int distance)"
		},
		{
			"forge": "skipDropExperience()",
			"fabric": "disableExperienceDropping()"
		},
		{
			"forge": "wasExperienceConsumed()",
			"fabric": "isExperienceDroppingDisabled()"
		},
		{
			"forge": "getMeleeAttackReferencePosition()",
			"fabric": "getAttackPos()"
		},
		{
			"forge": "getHurtDir()",
			"fabric": "getDamageTiltYaw()"
		},
		{
			"forge": "getFallSounds()",
			"fabric": "getFallSounds()"
		},
		{
			"forge": "getDrinkingSound(ItemStack arg0)",
			"fabric": "getDrinkSound(ItemStack stack)"
		},
		{
			"forge": "getEatingSound(ItemStack arg0)",
			"fabric": "getEatSound(ItemStack stack)"
		},
		{
			"forge": "getLastClimbablePos()",
			"fabric": "getClimbingPos()"
		},
		{
			"forge": "onClimbable()",
			"fabric": "isClimbing()"
		},
		{
			"forge": "trapdoorUsableAsLadder(BlockPos arg0, BlockState arg1)",
			"fabric": "canEnterTrapdoor(BlockPos pos, BlockState state)"
		},
		{
			"forge": "isAlive()",
			"fabric": "isAlive()"
		},
		{
			"forge": "causeFallDamage(float arg0, float arg1, DamageSource arg2)",
			"fabric": "handleFallDamage(float arg0, float arg1, DamageSource arg2)"
		},
		{
			"forge": "calculateFallDamage(float arg0, float arg1)",
			"fabric": "computeFallDamage(float fallDistance, float damageMultiplier)"
		},
		{
			"forge": "playBlockFallSound()",
			"fabric": "playBlockFallSound()"
		},
		{
			"forge": "animateHurt(float arg0)",
			"fabric": "animateDamage(float arg0)"
		},
		{
			"forge": "getArmorValue()",
			"fabric": "getArmor()"
		},
		{
			"forge": "hurtArmor(DamageSource arg0, float arg1)",
			"fabric": "damageArmor(DamageSource source, float amount)"
		},
		{
			"forge": "hurtHelmet(DamageSource arg0, float arg1)",
			"fabric": "damageHelmet(DamageSource source, float amount)"
		},
		{
			"forge": "hurtCurrentlyUsedShield(float arg0)",
			"fabric": "damageShield(float amount)"
		},
		{
			"forge": "getDamageAfterArmorAbsorb(DamageSource arg0, float arg1)",
			"fabric": "applyArmorToDamage(DamageSource source, float amount)"
		},
		{
			"forge": "getDamageAfterMagicAbsorb(DamageSource arg0, float arg1)",
			"fabric": "modifyAppliedDamage(DamageSource source, float amount)"
		},
		{
			"forge": "actuallyHurt(DamageSource arg0, float arg1)",
			"fabric": "applyDamage(DamageSource source, float amount)"
		},
		{
			"forge": "getCombatTracker()",
			"fabric": "getDamageTracker()"
		},
		{
			"forge": "getKillCredit()",
			"fabric": "getPrimeAdversary()"
		},
		{
			"forge": "getMaxHealth()",
			"fabric": "getMaxHealth()"
		},
		{
			"forge": "getArrowCount()",
			"fabric": "getStuckArrowCount()"
		},
		{
			"forge": "setArrowCount(int arg0)",
			"fabric": "setStuckArrowCount(int stuckArrowCount)"
		},
		{
			"forge": "getStingerCount()",
			"fabric": "getStingerCount()"
		},
		{
			"forge": "setStingerCount(int arg0)",
			"fabric": "setStingerCount(int stingerCount)"
		},
		{
			"forge": "getCurrentSwingDuration()",
			"fabric": "getHandSwingDuration()"
		},
		{
			"forge": "swing(InteractionHand arg0)",
			"fabric": "swingHand(Hand hand)"
		},
		{
			"forge": "swing(InteractionHand arg0, boolean arg1)",
			"fabric": "swingHand(Hand hand, boolean fromServerPlayer)"
		},
		{
			"forge": "handleDamageEvent(DamageSource arg0)",
			"fabric": "onDamaged(DamageSource arg0)"
		},
		{
			"forge": "handleEntityEvent(byte arg0)",
			"fabric": "handleStatus(byte arg0)"
		},
		{
			"forge": "makePoofParticles()",
			"fabric": "addDeathParticles()"
		},
		{
			"forge": "swapHandItems()",
			"fabric": "swapHandStacks()"
		},
		{
			"forge": "onBelowWorld()",
			"fabric": "tickInVoid()"
		},
		{
			"forge": "updateSwingTime()",
			"fabric": "tickHandSwing()"
		},
		{
			"forge": "getAttribute(Attribute arg0)",
			"fabric": "getAttributeInstance(EntityAttribute attribute)"
		},
		{
			"forge": "getAttributeValue(Holder<Attribute> arg0)",
			"fabric": "getAttributeValue(RegistryEntry<EntityAttribute> attribute)"
		},
		{
			"forge": "getAttributeValue(Attribute arg0)",
			"fabric": "getAttributeValue(EntityAttribute attribute)"
		},
		{
			"forge": "getAttributeBaseValue(Holder<Attribute> arg0)",
			"fabric": "getAttributeBaseValue(RegistryEntry<EntityAttribute> attribute)"
		},
		{
			"forge": "getAttributeBaseValue(Attribute arg0)",
			"fabric": "getAttributeBaseValue(EntityAttribute attribute)"
		},
		{
			"forge": "getAttributes()",
			"fabric": "getAttributes()"
		},
		{
			"forge": "getMobType()",
			"fabric": "getGroup()"
		},
		{
			"forge": "getMainHandItem()",
			"fabric": "getMainHandStack()"
		},
		{
			"forge": "getOffhandItem()",
			"fabric": "getOffHandStack()"
		},
		{
			"forge": "isHolding(Item arg0)",
			"fabric": "isHolding(Item item)"
		},
		{
			"forge": "isHolding(Predicate<ItemStack> arg0)",
			"fabric": "isHolding(Predicate<ItemStack> predicate)"
		},
		{
			"forge": "getItemInHand(InteractionHand arg0)",
			"fabric": "getStackInHand(Hand hand)"
		},
		{
			"forge": "setItemInHand(InteractionHand arg0, ItemStack arg1)",
			"fabric": "setStackInHand(Hand hand, ItemStack stack)"
		},
		{
			"forge": "hasItemInSlot(EquipmentSlot arg0)",
			"fabric": "hasStackEquipped(EquipmentSlot slot)"
		},
		{
			"forge": "getArmorSlots()",
			"fabric": "getArmorItems()"
		},
		{
			"forge": "getItemBySlot(EquipmentSlot arg0)",
			"fabric": "getEquippedStack(EquipmentSlot slot)"
		},
		{
			"forge": "setItemSlot(EquipmentSlot arg0, ItemStack arg1)",
			"fabric": "equipStack(EquipmentSlot arg0, ItemStack arg1)"
		},
		{
			"forge": "verifyEquippedItem(ItemStack arg0)",
			"fabric": "processEquippedStack(ItemStack stack)"
		},
		{
			"forge": "getArmorCoverPercentage()",
			"fabric": "getArmorVisibility()"
		},
		{
			"forge": "setSprinting(boolean arg0)",
			"fabric": "setSprinting(boolean arg0)"
		},
		{
			"forge": "getSoundVolume()",
			"fabric": "getSoundVolume()"
		},
		{
			"forge": "getVoicePitch()",
			"fabric": "getSoundPitch()"
		},
		{
			"forge": "isImmobile()",
			"fabric": "isImmobile()"
		},
		{
			"forge": "push(Entity arg0)",
			"fabric": "pushAwayFrom(Entity arg0)"
		},
		{
			"forge": "dismountVehicle(Entity arg0)",
			"fabric": "onDismounted(Entity vehicle)"
		},
		{
			"forge": "shouldShowName()",
			"fabric": "shouldRenderName()"
		},
		{
			"forge": "getJumpPower()",
			"fabric": "getJumpVelocity()"
		},
		{
			"forge": "getJumpBoostPower()",
			"fabric": "getJumpBoostVelocityModifier()"
		},
		{
			"forge": "jumpFromGround()",
			"fabric": "jump()"
		},
		{
			"forge": "goDownInWater()",
			"fabric": "knockDownwards()"
		},
		{
			"forge": "jumpInLiquid(TagKey<Fluid> arg0)",
			"fabric": "swimUpward(TagKey<Fluid> fluid)"
		},
		{
			"forge": "getWaterSlowDown()",
			"fabric": "getBaseMovementSpeedMultiplier()"
		},
		{
			"forge": "canStandOnFluid(FluidState arg0)",
			"fabric": "canWalkOnFluid(FluidState state)"
		},
		{
			"forge": "travel(Vec3 arg0)",
			"fabric": "travel(Vec3d movementInput)"
		},
		{
			"forge": "travelRidden(Player arg0, Vec3 arg1)",
			"fabric": "travelControlled(PlayerEntity controllingPlayer, Vec3d movementInput)"
		},
		{
			"forge": "tickRidden(Player arg0, Vec3 arg1)",
			"fabric": "tickControlled(PlayerEntity controllingPlayer, Vec3d movementInput)"
		},
		{
			"forge": "getRiddenInput(Player arg0, Vec3 arg1)",
			"fabric": "getControlledMovementInput(PlayerEntity controllingPlayer, Vec3d movementInput)"
		},
		{
			"forge": "getRiddenSpeed(Player arg0)",
			"fabric": "getSaddledSpeed(PlayerEntity controllingPlayer)"
		},
		{
			"forge": "calculateEntityAnimation(boolean arg0)",
			"fabric": "updateLimbs(boolean flutter)"
		},
		{
			"forge": "updateWalkAnimation(float arg0)",
			"fabric": "updateLimbs(float posDelta)"
		},
		{
			"forge": "handleRelativeFrictionAndCalculateMovement(Vec3 arg0, float arg1)",
			"fabric": "applyMovementInput(Vec3d movementInput, float slipperiness)"
		},
		{
			"forge": "getFluidFallingAdjustedMovement(double arg0, boolean arg1, Vec3 arg2)",
			"fabric": "applyFluidMovingSpeed(double gravity, boolean falling, Vec3d motion)"
		},
		{
			"forge": "handleOnClimbable(Vec3 arg0)",
			"fabric": "applyClimbingSpeed(Vec3d motion)"
		},
		{
			"forge": "getFrictionInfluencedSpeed(float arg0)",
			"fabric": "getMovementSpeed(float slipperiness)"
		},
		{
			"forge": "getFlyingSpeed()",
			"fabric": "getOffGroundSpeed()"
		},
		{
			"forge": "getSpeed()",
			"fabric": "getMovementSpeed()"
		},
		{
			"forge": "setSpeed(float arg0)",
			"fabric": "setMovementSpeed(float movementSpeed)"
		},
		{
			"forge": "doHurtTarget(Entity arg0)",
			"fabric": "tryAttack(Entity target)"
		},
		{
			"forge": "tick()",
			"fabric": "tick()"
		},
		{
			"forge": "detectEquipmentUpdates()",
			"fabric": "sendEquipmentChanges()"
		},
		{
			"forge": "collectEquipmentChanges()",
			"fabric": "getEquipmentChanges()"
		},
		{
			"forge": "equipmentHasChanged(ItemStack arg0, ItemStack arg1)",
			"fabric": "areItemsDifferent(ItemStack stack, ItemStack stack2)"
		},
		{
			"forge": "handleHandSwap(Map<EquipmentSlot, ItemStack> arg0)",
			"fabric": "checkHandStackSwap(Map<EquipmentSlot, ItemStack> equipmentChanges)"
		},
		{
			"forge": "handleEquipmentChanges(Map<EquipmentSlot, ItemStack> arg0)",
			"fabric": "sendEquipmentChanges(Map<EquipmentSlot, ItemStack> equipmentChanges)"
		},
		{
			"forge": "getLastArmorItem(EquipmentSlot arg0)",
			"fabric": "getSyncedArmorStack(EquipmentSlot slot)"
		},
		{
			"forge": "setLastArmorItem(EquipmentSlot arg0, ItemStack arg1)",
			"fabric": "setSyncedArmorStack(EquipmentSlot slot, ItemStack armor)"
		},
		{
			"forge": "getLastHandItem(EquipmentSlot arg0)",
			"fabric": "getSyncedHandStack(EquipmentSlot slot)"
		},
		{
			"forge": "setLastHandItem(EquipmentSlot arg0, ItemStack arg1)",
			"fabric": "setSyncedHandStack(EquipmentSlot slot, ItemStack stack)"
		},
		{
			"forge": "tickHeadTurn(float arg0, float arg1)",
			"fabric": "turnHead(float bodyRotation, float headRotation)"
		},
		{
			"forge": "aiStep()",
			"fabric": "tickMovement()"
		},
		{
			"forge": "isSensitiveToWater()",
			"fabric": "hurtByWater()"
		},
		{
			"forge": "updateFallFlying()",
			"fabric": "tickFallFlying()"
		},
		{
			"forge": "serverAiStep()",
			"fabric": "tickNewAi()"
		},
		{
			"forge": "pushEntities()",
			"fabric": "tickCramming()"
		},
		{
			"forge": "checkAutoSpinAttack(AABB arg0, AABB arg1)",
			"fabric": "tickRiptide(Box a, Box b)"
		},
		{
			"forge": "doPush(Entity arg0)",
			"fabric": "pushAway(Entity entity)"
		},
		{
			"forge": "doAutoAttackOnTouch(LivingEntity arg0)",
			"fabric": "attackLivingEntity(LivingEntity target)"
		},
		{
			"forge": "isAutoSpinAttack()",
			"fabric": "isUsingRiptide()"
		},
		{
			"forge": "stopRiding()",
			"fabric": "stopRiding()"
		},
		{
			"forge": "rideTick()",
			"fabric": "tickRiding()"
		},
		{
			"forge": "lerpTo(double arg0, double arg1, double arg2, float arg3, float arg4, int arg5, boolean arg6)",
			"fabric": "updateTrackedPositionAndAngles(double arg0, double arg1, double arg2, float arg3, float arg4, int arg5, boolean arg6)"
		},
		{
			"forge": "lerpHeadTo(float arg0, int arg1)",
			"fabric": "updateTrackedHeadRotation(float arg0, int arg1)"
		},
		{
			"forge": "setJumping(boolean arg0)",
			"fabric": "setJumping(boolean jumping)"
		},
		{
			"forge": "onItemPickup(ItemEntity arg0)",
			"fabric": "triggerItemPickedUpByEntityCriteria(ItemEntity item)"
		},
		{
			"forge": "take(Entity arg0, int arg1)",
			"fabric": "sendPickup(Entity item, int count)"
		},
		{
			"forge": "hasLineOfSight(Entity arg0)",
			"fabric": "canSee(Entity entity)"
		},
		{
			"forge": "getViewYRot(float arg0)",
			"fabric": "getYaw(float arg0)"
		},
		{
			"forge": "getAttackAnim(float arg0)",
			"fabric": "getHandSwingProgress(float tickDelta)"
		},
		{
			"forge": "isPickable()",
			"fabric": "canHit()"
		},
		{
			"forge": "isPushable()",
			"fabric": "isPushable()"
		},
		{
			"forge": "getYHeadRot()",
			"fabric": "getHeadYaw()"
		},
		{
			"forge": "setYHeadRot(float arg0)",
			"fabric": "setHeadYaw(float arg0)"
		},
		{
			"forge": "setYBodyRot(float arg0)",
			"fabric": "setBodyYaw(float arg0)"
		},
		{
			"forge": "getRelativePortalPosition(Direction$Axis arg0, BlockUtil$FoundRectangle arg1)",
			"fabric": "positionInPortal(Direction$Axis arg0, BlockLocating$Rectangle arg1)"
		},
		{
			"forge": "resetForwardDirectionOfRelativePortalPosition(Vec3 arg0)",
			"fabric": "positionInPortal(Vec3d pos)"
		},
		{
			"forge": "getAbsorptionAmount()",
			"fabric": "getAbsorptionAmount()"
		},
		{
			"forge": "setAbsorptionAmount(float arg0)",
			"fabric": "setAbsorptionAmount(float amount)"
		},
		{
			"forge": "onEnterCombat()",
			"fabric": "enterCombat()"
		},
		{
			"forge": "onLeaveCombat()",
			"fabric": "endCombat()"
		},
		{
			"forge": "updateEffectVisibility()",
			"fabric": "markEffectsDirty()"
		},
		{
			"forge": "getMainArm()",
			"fabric": "getMainArm()"
		},
		{
			"forge": "isUsingItem()",
			"fabric": "isUsingItem()"
		},
		{
			"forge": "getUsedItemHand()",
			"fabric": "getActiveHand()"
		},
		{
			"forge": "updatingUsingItem()",
			"fabric": "tickActiveItemStack()"
		},
		{
			"forge": "updateUsingItem(ItemStack arg0)",
			"fabric": "tickItemStackUsage(ItemStack stack)"
		},
		{
			"forge": "shouldTriggerItemUseEffects()",
			"fabric": "shouldSpawnConsumptionEffects()"
		},
		{
			"forge": "updateSwimAmount()",
			"fabric": "updateLeaningPitch()"
		},
		{
			"forge": "setLivingEntityFlag(int arg0, boolean arg1)",
			"fabric": "setLivingFlag(int mask, boolean value)"
		},
		{
			"forge": "startUsingItem(InteractionHand arg0)",
			"fabric": "setCurrentHand(Hand hand)"
		},
		{
			"forge": "onSyncedDataUpdated(EntityDataAccessor<?> arg0)",
			"fabric": "onTrackedDataSet(TrackedData<?> arg0)"
		},
		{
			"forge": "lookAt(EntityAnchorArgument$Anchor arg0, Vec3 arg1)",
			"fabric": "lookAt(EntityAnchorArgumentType$EntityAnchor arg0, Vec3d arg1)"
		},
		{
			"forge": "triggerItemUseEffects(ItemStack arg0, int arg1)",
			"fabric": "spawnConsumptionEffects(ItemStack stack, int particleCount)"
		},
		{
			"forge": "spawnItemParticles(ItemStack arg0, int arg1)",
			"fabric": "spawnItemParticles(ItemStack stack, int count)"
		},
		{
			"forge": "completeUsingItem()",
			"fabric": "consumeItem()"
		},
		{
			"forge": "getUseItem()",
			"fabric": "getActiveItem()"
		},
		{
			"forge": "getUseItemRemainingTicks()",
			"fabric": "getItemUseTimeLeft()"
		},
		{
			"forge": "getTicksUsingItem()",
			"fabric": "getItemUseTime()"
		},
		{
			"forge": "releaseUsingItem()",
			"fabric": "stopUsingItem()"
		},
		{
			"forge": "stopUsingItem()",
			"fabric": "clearActiveItem()"
		},
		{
			"forge": "isBlocking()",
			"fabric": "isBlocking()"
		},
		{
			"forge": "isSuppressingSlidingDownLadder()",
			"fabric": "isHoldingOntoLadder()"
		},
		{
			"forge": "isFallFlying()",
			"fabric": "isFallFlying()"
		},
		{
			"forge": "isVisuallySwimming()",
			"fabric": "isInSwimmingPose()"
		},
		{
			"forge": "getFallFlyingTicks()",
			"fabric": "getRoll()"
		},
		{
			"forge": "randomTeleport(double arg0, double arg1, double arg2, boolean arg3)",
			"fabric": "teleport(double x, double y, double z, boolean particleEffects)"
		},
		{
			"forge": "isAffectedByPotions()",
			"fabric": "isAffectedBySplashPotions()"
		},
		{
			"forge": "attackable()",
			"fabric": "isMobOrPlayer()"
		},
		{
			"forge": "setRecordPlayingNearby(BlockPos arg0, boolean arg1)",
			"fabric": "setNearbySongPlaying(BlockPos songPosition, boolean playing)"
		},
		{
			"forge": "canTakeItem(ItemStack arg0)",
			"fabric": "canEquip(ItemStack stack)"
		},
		{
			"forge": "getDimensions(Pose arg0)",
			"fabric": "getDimensions(EntityPose arg0)"
		},
		{
			"forge": "getDismountPoses()",
			"fabric": "getPoses()"
		},
		{
			"forge": "getLocalBoundsForPose(Pose arg0)",
			"fabric": "getBoundingBox(EntityPose pose)"
		},
		{
			"forge": "canChangeDimensions()",
			"fabric": "canUsePortals()"
		},
		{
			"forge": "getSleepingPos()",
			"fabric": "getSleepingPosition()"
		},
		{
			"forge": "setSleepingPos(BlockPos arg0)",
			"fabric": "setSleepingPosition(BlockPos pos)"
		},
		{
			"forge": "clearSleepingPos()",
			"fabric": "clearSleepingPosition()"
		},
		{
			"forge": "isSleeping()",
			"fabric": "isSleeping()"
		},
		{
			"forge": "startSleeping(BlockPos arg0)",
			"fabric": "sleep(BlockPos pos)"
		},
		{
			"forge": "setPosToBed(BlockPos arg0)",
			"fabric": "setPositionInBed(BlockPos pos)"
		},
		{
			"forge": "checkBedExists()",
			"fabric": "isSleepingInBed()"
		},
		{
			"forge": "stopSleeping()",
			"fabric": "wakeUp()"
		},
		{
			"forge": "getBedOrientation()",
			"fabric": "getSleepingDirection()"
		},
		{
			"forge": "isInWall()",
			"fabric": "isInsideWall()"
		},
		{
			"forge": "getEyeHeight(Pose arg0, EntityDimensions arg1)",
			"fabric": "getEyeHeight(EntityPose arg0, EntityDimensions arg1)"
		},
		{
			"forge": "getStandingEyeHeight(Pose arg0, EntityDimensions arg1)",
			"fabric": "getActiveEyeHeight(EntityPose pose, EntityDimensions dimensions)"
		},
		{
			"forge": "getProjectile(ItemStack arg0)",
			"fabric": "getProjectileType(ItemStack stack)"
		},
		{
			"forge": "eat(Level arg0, ItemStack arg1)",
			"fabric": "eatFood(World world, ItemStack stack)"
		},
		{
			"forge": "addEatEffect(ItemStack arg0, Level arg1, LivingEntity arg2)",
			"fabric": "applyFoodEffects(ItemStack stack, World world, LivingEntity targetEntity)"
		},
		{
			"forge": "entityEventForEquipmentBreak(EquipmentSlot arg0)",
			"fabric": "getEquipmentBreakStatus(EquipmentSlot slot)"
		},
		{
			"forge": "broadcastBreakEvent(EquipmentSlot arg0)",
			"fabric": "sendEquipmentBreakStatus(EquipmentSlot slot)"
		},
		{
			"forge": "broadcastBreakEvent(InteractionHand arg0)",
			"fabric": "sendToolBreakStatus(Hand hand)"
		},
		{
			"forge": "getBoundingBoxForCulling()",
			"fabric": "getVisibilityBoundingBox()"
		},
		{
			"forge": "getEquipmentSlotForItem(ItemStack arg0)",
			"fabric": "getPreferredEquipmentSlot(ItemStack stack)"
		},
		{
			"forge": "createEquipmentSlotAccess(LivingEntity arg0, EquipmentSlot arg1)",
			"fabric": "getStackReference(LivingEntity entity, EquipmentSlot slot)"
		},
		{
			"forge": "getEquipmentSlot(int arg0)",
			"fabric": "getEquipmentSlot(int slotId)"
		},
		{
			"forge": "getSlot(int arg0)",
			"fabric": "getStackReference(int arg0)"
		},
		{
			"forge": "canFreeze()",
			"fabric": "canFreeze()"
		},
		{
			"forge": "isCurrentlyGlowing()",
			"fabric": "isGlowing()"
		},
		{
			"forge": "getVisualRotationYInDegrees()",
			"fabric": "getBodyYaw()"
		},
		{
			"forge": "recreateFromPacket(ClientboundAddEntityPacket arg0)",
			"fabric": "onSpawnPacket(EntitySpawnS2CPacket arg0)"
		},
		{
			"forge": "canDisableShield()",
			"fabric": "disablesShield()"
		},
		{
			"forge": "maxUpStep()",
			"fabric": "getStepHeight()"
		}
	]
}